// Code generated by protoc-gen-zig
///! package meshtastic
const std = @import("std");

const protobuf = @import("protobuf");
const fd = protobuf.fd;

///
/// This information can be encoded as a QRcode/url so that other users can configure
/// their radio to join the same channel.
/// A note about how channel names are shown to users: channelname-X
/// poundsymbol is a prefix used to indicate this is a channel name (idea from @professr).
/// Where X is a letter from A-Z (base 26) representing a hash of the PSK for this
/// channel - so that if the user changes anything about the channel (which does
/// force a new PSK) this letter will also change. Thus preventing user confusion if
/// two friends try to type in a channel name of "BobsChan" and then can't talk
/// because their PSKs will be different.
/// The PSK is hashed into this letter by "0x41 + [xor all bytes of the psk ] modulo 26"
/// This also allows the option of someday if people have the PSK off (zero), the
/// users COULD type in a channel name and be able to talk.
/// FIXME: Add description of multi-channel support and how primary vs secondary channels are used.
/// FIXME: explain how apps use channels for security.
/// explain how remote settings and remote gpio are managed as an example
pub const ChannelSettings = struct {
    channel_num: u32 = 0,
    psk: []const u8 = &.{},
    name: []const u8 = &.{},
    id: u32 = 0,
    uplink_enabled: bool = false,
    downlink_enabled: bool = false,
    module_settings: ?ModuleSettings = null,

    pub const _desc_table = .{
        .channel_num = fd(1, .{ .scalar = .uint32 }),
        .psk = fd(2, .{ .scalar = .bytes }),
        .name = fd(3, .{ .scalar = .string }),
        .id = fd(4, .{ .scalar = .fixed32 }),
        .uplink_enabled = fd(5, .{ .scalar = .bool }),
        .downlink_enabled = fd(6, .{ .scalar = .bool }),
        .module_settings = fd(7, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// This message is specifically for modules to store per-channel configuration data.
pub const ModuleSettings = struct {
    position_precision: u32 = 0,
    is_muted: bool = false,

    pub const _desc_table = .{
        .position_precision = fd(1, .{ .scalar = .uint32 }),
        .is_muted = fd(2, .{ .scalar = .bool }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// A pair of a channel number, mode and the (sharable) settings for that channel
pub const Channel = struct {
    index: i32 = 0,
    settings: ?ChannelSettings = null,
    role: Channel.Role = @enumFromInt(0),

    pub const _desc_table = .{
        .index = fd(1, .{ .scalar = .int32 }),
        .settings = fd(2, .submessage),
        .role = fd(3, .@"enum"),
    };

    ///
    /// How this channel is being used (or not).
    /// Note: this field is an enum to give us options for the future.
    /// In particular, someday we might make a 'SCANNING' option.
    /// SCANNING channels could have different frequencies and the radio would
    /// occasionally check that freq to see if anything is being transmitted.
    /// For devices that have multiple physical radios attached, we could keep multiple PRIMARY/SCANNING channels active at once to allow
    /// cross band routing as needed.
    /// If a device has only a single radio (the common case) only one channel can be PRIMARY at a time
    /// (but any number of SECONDARY channels can't be sent received on that common frequency)
    pub const Role = enum(i32) {
        DISABLED = 0,
        PRIMARY = 1,
        SECONDARY = 2,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const CompassMode = enum(i32) {
    DYNAMIC = 0,
    FIXED_RING = 1,
    FREEZE_HEADING = 2,
    _,
};

pub const Theme = enum(i32) {
    DARK = 0,
    LIGHT = 1,
    RED = 2,
    _,
};

///
/// Localization
pub const Language = enum(i32) {
    ENGLISH = 0,
    FRENCH = 1,
    GERMAN = 2,
    ITALIAN = 3,
    PORTUGUESE = 4,
    SPANISH = 5,
    SWEDISH = 6,
    FINNISH = 7,
    POLISH = 8,
    TURKISH = 9,
    SERBIAN = 10,
    RUSSIAN = 11,
    DUTCH = 12,
    GREEK = 13,
    NORWEGIAN = 14,
    SLOVENIAN = 15,
    UKRAINIAN = 16,
    BULGARIAN = 17,
    CZECH = 18,
    DANISH = 19,
    SIMPLIFIED_CHINESE = 30,
    TRADITIONAL_CHINESE = 31,
    _,
};

pub const DeviceUIConfig = struct {
    version: u32 = 0,
    screen_brightness: u32 = 0,
    screen_timeout: u32 = 0,
    screen_lock: bool = false,
    settings_lock: bool = false,
    pin_code: u32 = 0,
    theme: Theme = @enumFromInt(0),
    alert_enabled: bool = false,
    banner_enabled: bool = false,
    ring_tone_id: u32 = 0,
    language: Language = @enumFromInt(0),
    node_filter: ?NodeFilter = null,
    node_highlight: ?NodeHighlight = null,
    calibration_data: []const u8 = &.{},
    map_data: ?Map = null,
    compass_mode: CompassMode = @enumFromInt(0),
    screen_rgb_color: u32 = 0,
    is_clockface_analog: bool = false,
    gps_format: DeviceUIConfig.GpsCoordinateFormat = @enumFromInt(0),

    pub const _desc_table = .{
        .version = fd(1, .{ .scalar = .uint32 }),
        .screen_brightness = fd(2, .{ .scalar = .uint32 }),
        .screen_timeout = fd(3, .{ .scalar = .uint32 }),
        .screen_lock = fd(4, .{ .scalar = .bool }),
        .settings_lock = fd(5, .{ .scalar = .bool }),
        .pin_code = fd(6, .{ .scalar = .uint32 }),
        .theme = fd(7, .@"enum"),
        .alert_enabled = fd(8, .{ .scalar = .bool }),
        .banner_enabled = fd(9, .{ .scalar = .bool }),
        .ring_tone_id = fd(10, .{ .scalar = .uint32 }),
        .language = fd(11, .@"enum"),
        .node_filter = fd(12, .submessage),
        .node_highlight = fd(13, .submessage),
        .calibration_data = fd(14, .{ .scalar = .bytes }),
        .map_data = fd(15, .submessage),
        .compass_mode = fd(16, .@"enum"),
        .screen_rgb_color = fd(17, .{ .scalar = .uint32 }),
        .is_clockface_analog = fd(18, .{ .scalar = .bool }),
        .gps_format = fd(19, .@"enum"),
    };

    ///
    /// How the GPS coordinates are displayed on the OLED screen.
    pub const GpsCoordinateFormat = enum(i32) {
        DEC = 0,
        DMS = 1,
        UTM = 2,
        MGRS = 3,
        OLC = 4,
        OSGR = 5,
        MLS = 6,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const NodeFilter = struct {
    unknown_switch: bool = false,
    offline_switch: bool = false,
    public_key_switch: bool = false,
    hops_away: i32 = 0,
    position_switch: bool = false,
    node_name: []const u8 = &.{},
    channel: i32 = 0,

    pub const _desc_table = .{
        .unknown_switch = fd(1, .{ .scalar = .bool }),
        .offline_switch = fd(2, .{ .scalar = .bool }),
        .public_key_switch = fd(3, .{ .scalar = .bool }),
        .hops_away = fd(4, .{ .scalar = .int32 }),
        .position_switch = fd(5, .{ .scalar = .bool }),
        .node_name = fd(6, .{ .scalar = .string }),
        .channel = fd(7, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const NodeHighlight = struct {
    chat_switch: bool = false,
    position_switch: bool = false,
    telemetry_switch: bool = false,
    iaq_switch: bool = false,
    node_name: []const u8 = &.{},

    pub const _desc_table = .{
        .chat_switch = fd(1, .{ .scalar = .bool }),
        .position_switch = fd(2, .{ .scalar = .bool }),
        .telemetry_switch = fd(3, .{ .scalar = .bool }),
        .iaq_switch = fd(4, .{ .scalar = .bool }),
        .node_name = fd(5, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const GeoPoint = struct {
    zoom: i32 = 0,
    latitude: i32 = 0,
    longitude: i32 = 0,

    pub const _desc_table = .{
        .zoom = fd(1, .{ .scalar = .int32 }),
        .latitude = fd(2, .{ .scalar = .int32 }),
        .longitude = fd(3, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Map = struct {
    home: ?GeoPoint = null,
    style: []const u8 = &.{},
    follow_gps: bool = false,

    pub const _desc_table = .{
        .home = fd(1, .submessage),
        .style = fd(2, .{ .scalar = .string }),
        .follow_gps = fd(3, .{ .scalar = .bool }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Config = struct {
    payload_variant: ?payload_variant_union = null,

    pub const _payload_variant_case = enum {
        device,
        position,
        power,
        network,
        display,
        lora,
        bluetooth,
        security,
        sessionkey,
        device_ui,
    };
    pub const payload_variant_union = union(_payload_variant_case) {
        device: Config.DeviceConfig,
        position: Config.PositionConfig,
        power: Config.PowerConfig,
        network: Config.NetworkConfig,
        display: Config.DisplayConfig,
        lora: Config.LoRaConfig,
        bluetooth: Config.BluetoothConfig,
        security: Config.SecurityConfig,
        sessionkey: Config.SessionkeyConfig,
        device_ui: DeviceUIConfig,
        pub const _desc_table = .{
            .device = fd(1, .submessage),
            .position = fd(2, .submessage),
            .power = fd(3, .submessage),
            .network = fd(4, .submessage),
            .display = fd(5, .submessage),
            .lora = fd(6, .submessage),
            .bluetooth = fd(7, .submessage),
            .security = fd(8, .submessage),
            .sessionkey = fd(9, .submessage),
            .device_ui = fd(10, .submessage),
        };
    };

    pub const _desc_table = .{
        .payload_variant = fd(null, .{ .oneof = payload_variant_union }),
    };

    ///
    /// Configuration
    pub const DeviceConfig = struct {
        role: Config.DeviceConfig.Role = @enumFromInt(0),
        serial_enabled: bool = false,
        button_gpio: u32 = 0,
        buzzer_gpio: u32 = 0,
        rebroadcast_mode: Config.DeviceConfig.RebroadcastMode = @enumFromInt(0),
        node_info_broadcast_secs: u32 = 0,
        double_tap_as_button_press: bool = false,
        is_managed: bool = false,
        disable_triple_click: bool = false,
        tzdef: []const u8 = &.{},
        led_heartbeat_disabled: bool = false,
        buzzer_mode: Config.DeviceConfig.BuzzerMode = @enumFromInt(0),

        pub const _desc_table = .{
            .role = fd(1, .@"enum"),
            .serial_enabled = fd(2, .{ .scalar = .bool }),
            .button_gpio = fd(4, .{ .scalar = .uint32 }),
            .buzzer_gpio = fd(5, .{ .scalar = .uint32 }),
            .rebroadcast_mode = fd(6, .@"enum"),
            .node_info_broadcast_secs = fd(7, .{ .scalar = .uint32 }),
            .double_tap_as_button_press = fd(8, .{ .scalar = .bool }),
            .is_managed = fd(9, .{ .scalar = .bool }),
            .disable_triple_click = fd(10, .{ .scalar = .bool }),
            .tzdef = fd(11, .{ .scalar = .string }),
            .led_heartbeat_disabled = fd(12, .{ .scalar = .bool }),
            .buzzer_mode = fd(13, .@"enum"),
        };

        ///
        /// Defines the device's role on the Mesh network
        pub const Role = enum(i32) {
            CLIENT = 0,
            CLIENT_MUTE = 1,
            ROUTER = 2,
            ROUTER_CLIENT = 3,
            REPEATER = 4,
            TRACKER = 5,
            SENSOR = 6,
            TAK = 7,
            CLIENT_HIDDEN = 8,
            LOST_AND_FOUND = 9,
            TAK_TRACKER = 10,
            ROUTER_LATE = 11,
            CLIENT_BASE = 12,
            _,
        };

        ///
        /// Defines the device's behavior for how messages are rebroadcast
        pub const RebroadcastMode = enum(i32) {
            ALL = 0,
            ALL_SKIP_DECODING = 1,
            LOCAL_ONLY = 2,
            KNOWN_ONLY = 3,
            NONE = 4,
            CORE_PORTNUMS_ONLY = 5,
            _,
        };

        ///
        /// Defines buzzer behavior for audio feedback
        pub const BuzzerMode = enum(i32) {
            ALL_ENABLED = 0,
            DISABLED = 1,
            NOTIFICATIONS_ONLY = 2,
            SYSTEM_ONLY = 3,
            DIRECT_MSG_ONLY = 4,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Position Config
    pub const PositionConfig = struct {
        position_broadcast_secs: u32 = 0,
        position_broadcast_smart_enabled: bool = false,
        fixed_position: bool = false,
        gps_enabled: bool = false,
        gps_update_interval: u32 = 0,
        gps_attempt_time: u32 = 0,
        position_flags: u32 = 0,
        rx_gpio: u32 = 0,
        tx_gpio: u32 = 0,
        broadcast_smart_minimum_distance: u32 = 0,
        broadcast_smart_minimum_interval_secs: u32 = 0,
        gps_en_gpio: u32 = 0,
        gps_mode: Config.PositionConfig.GpsMode = @enumFromInt(0),

        pub const _desc_table = .{
            .position_broadcast_secs = fd(1, .{ .scalar = .uint32 }),
            .position_broadcast_smart_enabled = fd(2, .{ .scalar = .bool }),
            .fixed_position = fd(3, .{ .scalar = .bool }),
            .gps_enabled = fd(4, .{ .scalar = .bool }),
            .gps_update_interval = fd(5, .{ .scalar = .uint32 }),
            .gps_attempt_time = fd(6, .{ .scalar = .uint32 }),
            .position_flags = fd(7, .{ .scalar = .uint32 }),
            .rx_gpio = fd(8, .{ .scalar = .uint32 }),
            .tx_gpio = fd(9, .{ .scalar = .uint32 }),
            .broadcast_smart_minimum_distance = fd(10, .{ .scalar = .uint32 }),
            .broadcast_smart_minimum_interval_secs = fd(11, .{ .scalar = .uint32 }),
            .gps_en_gpio = fd(12, .{ .scalar = .uint32 }),
            .gps_mode = fd(13, .@"enum"),
        };

        ///
        /// Bit field of boolean configuration options, indicating which optional
        /// fields to include when assembling POSITION messages.
        /// Longitude, latitude, altitude, speed, heading, and DOP
        /// are always included (also time if GPS-synced)
        /// NOTE: the more fields are included, the larger the message will be -
        /// leading to longer airtime and a higher risk of packet loss
        pub const PositionFlags = enum(i32) {
            UNSET = 0,
            ALTITUDE = 1,
            ALTITUDE_MSL = 2,
            GEOIDAL_SEPARATION = 4,
            DOP = 8,
            HVDOP = 16,
            SATINVIEW = 32,
            SEQ_NO = 64,
            TIMESTAMP = 128,
            HEADING = 256,
            SPEED = 512,
            _,
        };

        pub const GpsMode = enum(i32) {
            DISABLED = 0,
            ENABLED = 1,
            NOT_PRESENT = 2,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Power Config\
    /// See [Power Config](/docs/settings/config/power) for additional power config details.
    pub const PowerConfig = struct {
        is_power_saving: bool = false,
        on_battery_shutdown_after_secs: u32 = 0,
        adc_multiplier_override: f32 = 0,
        wait_bluetooth_secs: u32 = 0,
        sds_secs: u32 = 0,
        ls_secs: u32 = 0,
        min_wake_secs: u32 = 0,
        device_battery_ina_address: u32 = 0,
        powermon_enables: u64 = 0,

        pub const _desc_table = .{
            .is_power_saving = fd(1, .{ .scalar = .bool }),
            .on_battery_shutdown_after_secs = fd(2, .{ .scalar = .uint32 }),
            .adc_multiplier_override = fd(3, .{ .scalar = .float }),
            .wait_bluetooth_secs = fd(4, .{ .scalar = .uint32 }),
            .sds_secs = fd(6, .{ .scalar = .uint32 }),
            .ls_secs = fd(7, .{ .scalar = .uint32 }),
            .min_wake_secs = fd(8, .{ .scalar = .uint32 }),
            .device_battery_ina_address = fd(9, .{ .scalar = .uint32 }),
            .powermon_enables = fd(32, .{ .scalar = .uint64 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Network Config
    pub const NetworkConfig = struct {
        wifi_enabled: bool = false,
        wifi_ssid: []const u8 = &.{},
        wifi_psk: []const u8 = &.{},
        ntp_server: []const u8 = &.{},
        eth_enabled: bool = false,
        address_mode: Config.NetworkConfig.AddressMode = @enumFromInt(0),
        ipv4_config: ?Config.NetworkConfig.IpV4Config = null,
        rsyslog_server: []const u8 = &.{},
        enabled_protocols: u32 = 0,
        ipv6_enabled: bool = false,

        pub const _desc_table = .{
            .wifi_enabled = fd(1, .{ .scalar = .bool }),
            .wifi_ssid = fd(3, .{ .scalar = .string }),
            .wifi_psk = fd(4, .{ .scalar = .string }),
            .ntp_server = fd(5, .{ .scalar = .string }),
            .eth_enabled = fd(6, .{ .scalar = .bool }),
            .address_mode = fd(7, .@"enum"),
            .ipv4_config = fd(8, .submessage),
            .rsyslog_server = fd(9, .{ .scalar = .string }),
            .enabled_protocols = fd(10, .{ .scalar = .uint32 }),
            .ipv6_enabled = fd(11, .{ .scalar = .bool }),
        };

        pub const AddressMode = enum(i32) {
            DHCP = 0,
            STATIC = 1,
            _,
        };

        ///
        /// Available flags auxiliary network protocols
        pub const ProtocolFlags = enum(i32) {
            NO_BROADCAST = 0,
            UDP_BROADCAST = 1,
            _,
        };

        pub const IpV4Config = struct {
            ip: u32 = 0,
            gateway: u32 = 0,
            subnet: u32 = 0,
            dns: u32 = 0,

            pub const _desc_table = .{
                .ip = fd(1, .{ .scalar = .fixed32 }),
                .gateway = fd(2, .{ .scalar = .fixed32 }),
                .subnet = fd(3, .{ .scalar = .fixed32 }),
                .dns = fd(4, .{ .scalar = .fixed32 }),
            };

            /// Encodes the message to the writer
            /// The allocator is used to generate submessages internally.
            /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
            pub fn encode(
                self: @This(),
                writer: *std.Io.Writer,
                allocator: std.mem.Allocator,
            ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
                return protobuf.encode(writer, allocator, self);
            }

            /// Decodes the message from the bytes read from the reader.
            pub fn decode(
                reader: *std.Io.Reader,
                allocator: std.mem.Allocator,
            ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
                return protobuf.decode(@This(), reader, allocator);
            }

            /// Deinitializes and frees the memory associated with the message.
            pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
                return protobuf.deinit(allocator, self);
            }

            /// Duplicates the message.
            pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
                return protobuf.dupe(@This(), self, allocator);
            }

            /// Decodes the message from the JSON string.
            pub fn jsonDecode(
                input: []const u8,
                options: std.json.ParseOptions,
                allocator: std.mem.Allocator,
            ) !std.json.Parsed(@This()) {
                return protobuf.json.decode(@This(), input, options, allocator);
            }

            /// Encodes the message to a JSON string.
            pub fn jsonEncode(
                self: @This(),
                options: std.json.Stringify.Options,
                allocator: std.mem.Allocator,
            ) ![]const u8 {
                return protobuf.json.encode(self, options, allocator);
            }

            /// This method is used by std.json
            /// internally for deserialization. DO NOT RENAME!
            pub fn jsonParse(
                allocator: std.mem.Allocator,
                source: anytype,
                options: std.json.ParseOptions,
            ) !@This() {
                return protobuf.json.parse(@This(), allocator, source, options);
            }

            /// This method is used by std.json
            /// internally for serialization. DO NOT RENAME!
            pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                return protobuf.json.stringify(@This(), self, jws);
            }
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Display Config
    pub const DisplayConfig = struct {
        screen_on_secs: u32 = 0,
        gps_format: Config.DisplayConfig.DeprecatedGpsCoordinateFormat = @enumFromInt(0),
        auto_screen_carousel_secs: u32 = 0,
        compass_north_top: bool = false,
        flip_screen: bool = false,
        units: Config.DisplayConfig.DisplayUnits = @enumFromInt(0),
        oled: Config.DisplayConfig.OledType = @enumFromInt(0),
        displaymode: Config.DisplayConfig.DisplayMode = @enumFromInt(0),
        heading_bold: bool = false,
        wake_on_tap_or_motion: bool = false,
        compass_orientation: Config.DisplayConfig.CompassOrientation = @enumFromInt(0),
        use_12h_clock: bool = false,
        use_long_node_name: bool = false,
        enable_message_bubbles: bool = false,

        pub const _desc_table = .{
            .screen_on_secs = fd(1, .{ .scalar = .uint32 }),
            .gps_format = fd(2, .@"enum"),
            .auto_screen_carousel_secs = fd(3, .{ .scalar = .uint32 }),
            .compass_north_top = fd(4, .{ .scalar = .bool }),
            .flip_screen = fd(5, .{ .scalar = .bool }),
            .units = fd(6, .@"enum"),
            .oled = fd(7, .@"enum"),
            .displaymode = fd(8, .@"enum"),
            .heading_bold = fd(9, .{ .scalar = .bool }),
            .wake_on_tap_or_motion = fd(10, .{ .scalar = .bool }),
            .compass_orientation = fd(11, .@"enum"),
            .use_12h_clock = fd(12, .{ .scalar = .bool }),
            .use_long_node_name = fd(13, .{ .scalar = .bool }),
            .enable_message_bubbles = fd(14, .{ .scalar = .bool }),
        };

        ///
        /// Deprecated in 2.7.4: Unused
        pub const DeprecatedGpsCoordinateFormat = enum(i32) {
            UNUSED = 0,
            _,
        };

        ///
        /// Unit display preference
        pub const DisplayUnits = enum(i32) {
            METRIC = 0,
            IMPERIAL = 1,
            _,
        };

        ///
        /// Override OLED outo detect with this if it fails.
        pub const OledType = enum(i32) {
            OLED_AUTO = 0,
            OLED_SSD1306 = 1,
            OLED_SH1106 = 2,
            OLED_SH1107 = 3,
            OLED_SH1107_128_128 = 4,
            _,
        };

        pub const DisplayMode = enum(i32) {
            DEFAULT = 0,
            TWOCOLOR = 1,
            INVERTED = 2,
            COLOR = 3,
            _,
        };

        pub const CompassOrientation = enum(i32) {
            DEGREES_0 = 0,
            DEGREES_90 = 1,
            DEGREES_180 = 2,
            DEGREES_270 = 3,
            DEGREES_0_INVERTED = 4,
            DEGREES_90_INVERTED = 5,
            DEGREES_180_INVERTED = 6,
            DEGREES_270_INVERTED = 7,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Lora Config
    pub const LoRaConfig = struct {
        use_preset: bool = false,
        modem_preset: Config.LoRaConfig.ModemPreset = @enumFromInt(0),
        bandwidth: u32 = 0,
        spread_factor: u32 = 0,
        coding_rate: u32 = 0,
        frequency_offset: f32 = 0,
        region: Config.LoRaConfig.RegionCode = @enumFromInt(0),
        hop_limit: u32 = 0,
        tx_enabled: bool = false,
        tx_power: i32 = 0,
        channel_num: u32 = 0,
        override_duty_cycle: bool = false,
        sx126x_rx_boosted_gain: bool = false,
        override_frequency: f32 = 0,
        pa_fan_disabled: bool = false,
        ignore_incoming: std.ArrayListUnmanaged(u32) = .empty,
        ignore_mqtt: bool = false,
        config_ok_to_mqtt: bool = false,

        pub const _desc_table = .{
            .use_preset = fd(1, .{ .scalar = .bool }),
            .modem_preset = fd(2, .@"enum"),
            .bandwidth = fd(3, .{ .scalar = .uint32 }),
            .spread_factor = fd(4, .{ .scalar = .uint32 }),
            .coding_rate = fd(5, .{ .scalar = .uint32 }),
            .frequency_offset = fd(6, .{ .scalar = .float }),
            .region = fd(7, .@"enum"),
            .hop_limit = fd(8, .{ .scalar = .uint32 }),
            .tx_enabled = fd(9, .{ .scalar = .bool }),
            .tx_power = fd(10, .{ .scalar = .int32 }),
            .channel_num = fd(11, .{ .scalar = .uint32 }),
            .override_duty_cycle = fd(12, .{ .scalar = .bool }),
            .sx126x_rx_boosted_gain = fd(13, .{ .scalar = .bool }),
            .override_frequency = fd(14, .{ .scalar = .float }),
            .pa_fan_disabled = fd(15, .{ .scalar = .bool }),
            .ignore_incoming = fd(103, .{ .packed_repeated = .{ .scalar = .uint32 } }),
            .ignore_mqtt = fd(104, .{ .scalar = .bool }),
            .config_ok_to_mqtt = fd(105, .{ .scalar = .bool }),
        };

        pub const RegionCode = enum(i32) {
            UNSET = 0,
            US = 1,
            EU_433 = 2,
            EU_868 = 3,
            CN = 4,
            JP = 5,
            ANZ = 6,
            KR = 7,
            TW = 8,
            RU = 9,
            IN = 10,
            NZ_865 = 11,
            TH = 12,
            LORA_24 = 13,
            UA_433 = 14,
            UA_868 = 15,
            MY_433 = 16,
            MY_919 = 17,
            SG_923 = 18,
            PH_433 = 19,
            PH_868 = 20,
            PH_915 = 21,
            ANZ_433 = 22,
            KZ_433 = 23,
            KZ_863 = 24,
            NP_865 = 25,
            BR_902 = 26,
            _,
        };

        ///
        /// Standard predefined channel settings
        /// Note: these mappings must match ModemPreset Choice in the device code.
        pub const ModemPreset = enum(i32) {
            LONG_FAST = 0,
            LONG_SLOW = 1,
            VERY_LONG_SLOW = 2,
            MEDIUM_SLOW = 3,
            MEDIUM_FAST = 4,
            SHORT_SLOW = 5,
            SHORT_FAST = 6,
            LONG_MODERATE = 7,
            SHORT_TURBO = 8,
            LONG_TURBO = 9,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const BluetoothConfig = struct {
        enabled: bool = false,
        mode: Config.BluetoothConfig.PairingMode = @enumFromInt(0),
        fixed_pin: u32 = 0,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .mode = fd(2, .@"enum"),
            .fixed_pin = fd(3, .{ .scalar = .uint32 }),
        };

        pub const PairingMode = enum(i32) {
            RANDOM_PIN = 0,
            FIXED_PIN = 1,
            NO_PIN = 2,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const SecurityConfig = struct {
        public_key: []const u8 = &.{},
        private_key: []const u8 = &.{},
        admin_key: std.ArrayListUnmanaged([]const u8) = .empty,
        is_managed: bool = false,
        serial_enabled: bool = false,
        debug_log_api_enabled: bool = false,
        admin_channel_enabled: bool = false,

        pub const _desc_table = .{
            .public_key = fd(1, .{ .scalar = .bytes }),
            .private_key = fd(2, .{ .scalar = .bytes }),
            .admin_key = fd(3, .{ .repeated = .{ .scalar = .bytes } }),
            .is_managed = fd(4, .{ .scalar = .bool }),
            .serial_enabled = fd(5, .{ .scalar = .bool }),
            .debug_log_api_enabled = fd(6, .{ .scalar = .bool }),
            .admin_channel_enabled = fd(8, .{ .scalar = .bool }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Blank config request, strictly for getting the session key
    pub const SessionkeyConfig = struct {
        pub const _desc_table = .{};

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Team = enum(i32) {
    Unspecifed_Color = 0,
    White = 1,
    Yellow = 2,
    Orange = 3,
    Magenta = 4,
    Red = 5,
    Maroon = 6,
    Purple = 7,
    Dark_Blue = 8,
    Blue = 9,
    Cyan = 10,
    Teal = 11,
    Green = 12,
    Dark_Green = 13,
    Brown = 14,
    _,
};

///
/// Role of the group member
pub const MemberRole = enum(i32) {
    Unspecifed = 0,
    TeamMember = 1,
    TeamLead = 2,
    HQ = 3,
    Sniper = 4,
    Medic = 5,
    ForwardObserver = 6,
    RTO = 7,
    K9 = 8,
    _,
};

///
/// Packets for the official ATAK Plugin
pub const TAKPacket = struct {
    is_compressed: bool = false,
    contact: ?Contact = null,
    group: ?Group = null,
    status: ?Status = null,
    payload_variant: ?payload_variant_union = null,

    pub const _payload_variant_case = enum {
        pli,
        chat,
        detail,
    };
    pub const payload_variant_union = union(_payload_variant_case) {
        pli: PLI,
        chat: GeoChat,
        detail: []const u8,
        pub const _desc_table = .{
            .pli = fd(5, .submessage),
            .chat = fd(6, .submessage),
            .detail = fd(7, .{ .scalar = .bytes }),
        };
    };

    pub const _desc_table = .{
        .is_compressed = fd(1, .{ .scalar = .bool }),
        .contact = fd(2, .submessage),
        .group = fd(3, .submessage),
        .status = fd(4, .submessage),
        .payload_variant = fd(null, .{ .oneof = payload_variant_union }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// ATAK GeoChat message
pub const GeoChat = struct {
    message: []const u8 = &.{},
    to: ?[]const u8 = null,
    to_callsign: ?[]const u8 = null,

    pub const _desc_table = .{
        .message = fd(1, .{ .scalar = .string }),
        .to = fd(2, .{ .scalar = .string }),
        .to_callsign = fd(3, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// ATAK Group
/// <__group role='Team Member' name='Cyan'/>
pub const Group = struct {
    role: MemberRole = @enumFromInt(0),
    team: Team = @enumFromInt(0),

    pub const _desc_table = .{
        .role = fd(1, .@"enum"),
        .team = fd(2, .@"enum"),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// ATAK EUD Status
/// <status battery='100' />
pub const Status = struct {
    battery: u32 = 0,

    pub const _desc_table = .{
        .battery = fd(1, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// ATAK Contact
/// <contact endpoint='0.0.0.0:4242:tcp' phone='+12345678' callsign='FALKE'/>
pub const Contact = struct {
    callsign: []const u8 = &.{},
    device_callsign: []const u8 = &.{},

    pub const _desc_table = .{
        .callsign = fd(1, .{ .scalar = .string }),
        .device_callsign = fd(2, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Position Location Information from ATAK
pub const PLI = struct {
    latitude_i: i32 = 0,
    longitude_i: i32 = 0,
    altitude: i32 = 0,
    speed: u32 = 0,
    course: u32 = 0,

    pub const _desc_table = .{
        .latitude_i = fd(1, .{ .scalar = .sfixed32 }),
        .longitude_i = fd(2, .{ .scalar = .sfixed32 }),
        .altitude = fd(3, .{ .scalar = .int32 }),
        .speed = fd(4, .{ .scalar = .uint32 }),
        .course = fd(5, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const RemoteHardwarePinType = enum(i32) {
    UNKNOWN = 0,
    DIGITAL_READ = 1,
    DIGITAL_WRITE = 2,
    _,
};

///
/// Module Config
pub const ModuleConfig = struct {
    payload_variant: ?payload_variant_union = null,

    pub const _payload_variant_case = enum {
        mqtt,
        serial,
        external_notification,
        store_forward,
        range_test,
        telemetry,
        canned_message,
        audio,
        remote_hardware,
        neighbor_info,
        ambient_lighting,
        detection_sensor,
        paxcounter,
        statusmessage,
        traffic_management,
        tak,
    };
    pub const payload_variant_union = union(_payload_variant_case) {
        mqtt: ModuleConfig.MQTTConfig,
        serial: ModuleConfig.SerialConfig,
        external_notification: ModuleConfig.ExternalNotificationConfig,
        store_forward: ModuleConfig.StoreForwardConfig,
        range_test: ModuleConfig.RangeTestConfig,
        telemetry: ModuleConfig.TelemetryConfig,
        canned_message: ModuleConfig.CannedMessageConfig,
        audio: ModuleConfig.AudioConfig,
        remote_hardware: ModuleConfig.RemoteHardwareConfig,
        neighbor_info: ModuleConfig.NeighborInfoConfig,
        ambient_lighting: ModuleConfig.AmbientLightingConfig,
        detection_sensor: ModuleConfig.DetectionSensorConfig,
        paxcounter: ModuleConfig.PaxcounterConfig,
        statusmessage: ModuleConfig.StatusMessageConfig,
        traffic_management: ModuleConfig.TrafficManagementConfig,
        tak: ModuleConfig.TAKConfig,
        pub const _desc_table = .{
            .mqtt = fd(1, .submessage),
            .serial = fd(2, .submessage),
            .external_notification = fd(3, .submessage),
            .store_forward = fd(4, .submessage),
            .range_test = fd(5, .submessage),
            .telemetry = fd(6, .submessage),
            .canned_message = fd(7, .submessage),
            .audio = fd(8, .submessage),
            .remote_hardware = fd(9, .submessage),
            .neighbor_info = fd(10, .submessage),
            .ambient_lighting = fd(11, .submessage),
            .detection_sensor = fd(12, .submessage),
            .paxcounter = fd(13, .submessage),
            .statusmessage = fd(14, .submessage),
            .traffic_management = fd(15, .submessage),
            .tak = fd(16, .submessage),
        };
    };

    pub const _desc_table = .{
        .payload_variant = fd(null, .{ .oneof = payload_variant_union }),
    };

    ///
    /// MQTT Client Config
    pub const MQTTConfig = struct {
        enabled: bool = false,
        address: []const u8 = &.{},
        username: []const u8 = &.{},
        password: []const u8 = &.{},
        encryption_enabled: bool = false,
        json_enabled: bool = false,
        tls_enabled: bool = false,
        root: []const u8 = &.{},
        proxy_to_client_enabled: bool = false,
        map_reporting_enabled: bool = false,
        map_report_settings: ?ModuleConfig.MapReportSettings = null,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .address = fd(2, .{ .scalar = .string }),
            .username = fd(3, .{ .scalar = .string }),
            .password = fd(4, .{ .scalar = .string }),
            .encryption_enabled = fd(5, .{ .scalar = .bool }),
            .json_enabled = fd(6, .{ .scalar = .bool }),
            .tls_enabled = fd(7, .{ .scalar = .bool }),
            .root = fd(8, .{ .scalar = .string }),
            .proxy_to_client_enabled = fd(9, .{ .scalar = .bool }),
            .map_reporting_enabled = fd(10, .{ .scalar = .bool }),
            .map_report_settings = fd(11, .submessage),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Settings for reporting unencrypted information about our node to a map via MQTT
    pub const MapReportSettings = struct {
        publish_interval_secs: u32 = 0,
        position_precision: u32 = 0,
        should_report_location: bool = false,

        pub const _desc_table = .{
            .publish_interval_secs = fd(1, .{ .scalar = .uint32 }),
            .position_precision = fd(2, .{ .scalar = .uint32 }),
            .should_report_location = fd(3, .{ .scalar = .bool }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// RemoteHardwareModule Config
    pub const RemoteHardwareConfig = struct {
        enabled: bool = false,
        allow_undefined_pin_access: bool = false,
        available_pins: std.ArrayListUnmanaged(RemoteHardwarePin) = .empty,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .allow_undefined_pin_access = fd(2, .{ .scalar = .bool }),
            .available_pins = fd(3, .{ .repeated = .submessage }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// NeighborInfoModule Config
    pub const NeighborInfoConfig = struct {
        enabled: bool = false,
        update_interval: u32 = 0,
        transmit_over_lora: bool = false,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .update_interval = fd(2, .{ .scalar = .uint32 }),
            .transmit_over_lora = fd(3, .{ .scalar = .bool }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Detection Sensor Module Config
    pub const DetectionSensorConfig = struct {
        enabled: bool = false,
        minimum_broadcast_secs: u32 = 0,
        state_broadcast_secs: u32 = 0,
        send_bell: bool = false,
        name: []const u8 = &.{},
        monitor_pin: u32 = 0,
        detection_trigger_type: ModuleConfig.DetectionSensorConfig.TriggerType = @enumFromInt(0),
        use_pullup: bool = false,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .minimum_broadcast_secs = fd(2, .{ .scalar = .uint32 }),
            .state_broadcast_secs = fd(3, .{ .scalar = .uint32 }),
            .send_bell = fd(4, .{ .scalar = .bool }),
            .name = fd(5, .{ .scalar = .string }),
            .monitor_pin = fd(6, .{ .scalar = .uint32 }),
            .detection_trigger_type = fd(7, .@"enum"),
            .use_pullup = fd(8, .{ .scalar = .bool }),
        };

        pub const TriggerType = enum(i32) {
            LOGIC_LOW = 0,
            LOGIC_HIGH = 1,
            FALLING_EDGE = 2,
            RISING_EDGE = 3,
            EITHER_EDGE_ACTIVE_LOW = 4,
            EITHER_EDGE_ACTIVE_HIGH = 5,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Audio Config for codec2 voice
    pub const AudioConfig = struct {
        codec2_enabled: bool = false,
        ptt_pin: u32 = 0,
        bitrate: ModuleConfig.AudioConfig.Audio_Baud = @enumFromInt(0),
        i2s_ws: u32 = 0,
        i2s_sd: u32 = 0,
        i2s_din: u32 = 0,
        i2s_sck: u32 = 0,

        pub const _desc_table = .{
            .codec2_enabled = fd(1, .{ .scalar = .bool }),
            .ptt_pin = fd(2, .{ .scalar = .uint32 }),
            .bitrate = fd(3, .@"enum"),
            .i2s_ws = fd(4, .{ .scalar = .uint32 }),
            .i2s_sd = fd(5, .{ .scalar = .uint32 }),
            .i2s_din = fd(6, .{ .scalar = .uint32 }),
            .i2s_sck = fd(7, .{ .scalar = .uint32 }),
        };

        ///
        /// Baudrate for codec2 voice
        pub const Audio_Baud = enum(i32) {
            CODEC2_DEFAULT = 0,
            CODEC2_3200 = 1,
            CODEC2_2400 = 2,
            CODEC2_1600 = 3,
            CODEC2_1400 = 4,
            CODEC2_1300 = 5,
            CODEC2_1200 = 6,
            CODEC2_700 = 7,
            CODEC2_700B = 8,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Config for the Paxcounter Module
    pub const PaxcounterConfig = struct {
        enabled: bool = false,
        paxcounter_update_interval: u32 = 0,
        wifi_threshold: i32 = 0,
        ble_threshold: i32 = 0,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .paxcounter_update_interval = fd(2, .{ .scalar = .uint32 }),
            .wifi_threshold = fd(3, .{ .scalar = .int32 }),
            .ble_threshold = fd(4, .{ .scalar = .int32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Config for the Traffic Management module.
    /// Provides packet inspection and traffic shaping to help reduce channel utilization
    pub const TrafficManagementConfig = struct {
        enabled: bool = false,
        position_dedup_enabled: bool = false,
        position_precision_bits: u32 = 0,
        position_min_interval_secs: u32 = 0,
        nodeinfo_direct_response: bool = false,
        nodeinfo_direct_response_max_hops: u32 = 0,
        rate_limit_enabled: bool = false,
        rate_limit_window_secs: u32 = 0,
        rate_limit_max_packets: u32 = 0,
        drop_unknown_enabled: bool = false,
        unknown_packet_threshold: u32 = 0,
        exhaust_hop_telemetry: bool = false,
        exhaust_hop_position: bool = false,
        router_preserve_hops: bool = false,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .position_dedup_enabled = fd(2, .{ .scalar = .bool }),
            .position_precision_bits = fd(3, .{ .scalar = .uint32 }),
            .position_min_interval_secs = fd(4, .{ .scalar = .uint32 }),
            .nodeinfo_direct_response = fd(5, .{ .scalar = .bool }),
            .nodeinfo_direct_response_max_hops = fd(6, .{ .scalar = .uint32 }),
            .rate_limit_enabled = fd(7, .{ .scalar = .bool }),
            .rate_limit_window_secs = fd(8, .{ .scalar = .uint32 }),
            .rate_limit_max_packets = fd(9, .{ .scalar = .uint32 }),
            .drop_unknown_enabled = fd(10, .{ .scalar = .bool }),
            .unknown_packet_threshold = fd(11, .{ .scalar = .uint32 }),
            .exhaust_hop_telemetry = fd(12, .{ .scalar = .bool }),
            .exhaust_hop_position = fd(13, .{ .scalar = .bool }),
            .router_preserve_hops = fd(14, .{ .scalar = .bool }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Serial Config
    pub const SerialConfig = struct {
        enabled: bool = false,
        echo: bool = false,
        rxd: u32 = 0,
        txd: u32 = 0,
        baud: ModuleConfig.SerialConfig.Serial_Baud = @enumFromInt(0),
        timeout: u32 = 0,
        mode: ModuleConfig.SerialConfig.Serial_Mode = @enumFromInt(0),
        override_console_serial_port: bool = false,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .echo = fd(2, .{ .scalar = .bool }),
            .rxd = fd(3, .{ .scalar = .uint32 }),
            .txd = fd(4, .{ .scalar = .uint32 }),
            .baud = fd(5, .@"enum"),
            .timeout = fd(6, .{ .scalar = .uint32 }),
            .mode = fd(7, .@"enum"),
            .override_console_serial_port = fd(8, .{ .scalar = .bool }),
        };

        ///
        /// TODO: REPLACE
        pub const Serial_Baud = enum(i32) {
            BAUD_DEFAULT = 0,
            BAUD_110 = 1,
            BAUD_300 = 2,
            BAUD_600 = 3,
            BAUD_1200 = 4,
            BAUD_2400 = 5,
            BAUD_4800 = 6,
            BAUD_9600 = 7,
            BAUD_19200 = 8,
            BAUD_38400 = 9,
            BAUD_57600 = 10,
            BAUD_115200 = 11,
            BAUD_230400 = 12,
            BAUD_460800 = 13,
            BAUD_576000 = 14,
            BAUD_921600 = 15,
            _,
        };

        ///
        /// TODO: REPLACE
        pub const Serial_Mode = enum(i32) {
            DEFAULT = 0,
            SIMPLE = 1,
            PROTO = 2,
            TEXTMSG = 3,
            NMEA = 4,
            CALTOPO = 5,
            WS85 = 6,
            VE_DIRECT = 7,
            MS_CONFIG = 8,
            LOG = 9,
            LOGTEXT = 10,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// External Notifications Config
    pub const ExternalNotificationConfig = struct {
        enabled: bool = false,
        output_ms: u32 = 0,
        output: u32 = 0,
        output_vibra: u32 = 0,
        output_buzzer: u32 = 0,
        active: bool = false,
        alert_message: bool = false,
        alert_message_vibra: bool = false,
        alert_message_buzzer: bool = false,
        alert_bell: bool = false,
        alert_bell_vibra: bool = false,
        alert_bell_buzzer: bool = false,
        use_pwm: bool = false,
        nag_timeout: u32 = 0,
        use_i2s_as_buzzer: bool = false,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .output_ms = fd(2, .{ .scalar = .uint32 }),
            .output = fd(3, .{ .scalar = .uint32 }),
            .output_vibra = fd(8, .{ .scalar = .uint32 }),
            .output_buzzer = fd(9, .{ .scalar = .uint32 }),
            .active = fd(4, .{ .scalar = .bool }),
            .alert_message = fd(5, .{ .scalar = .bool }),
            .alert_message_vibra = fd(10, .{ .scalar = .bool }),
            .alert_message_buzzer = fd(11, .{ .scalar = .bool }),
            .alert_bell = fd(6, .{ .scalar = .bool }),
            .alert_bell_vibra = fd(12, .{ .scalar = .bool }),
            .alert_bell_buzzer = fd(13, .{ .scalar = .bool }),
            .use_pwm = fd(7, .{ .scalar = .bool }),
            .nag_timeout = fd(14, .{ .scalar = .uint32 }),
            .use_i2s_as_buzzer = fd(15, .{ .scalar = .bool }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Store and Forward Module Config
    pub const StoreForwardConfig = struct {
        enabled: bool = false,
        heartbeat: bool = false,
        records: u32 = 0,
        history_return_max: u32 = 0,
        history_return_window: u32 = 0,
        is_server: bool = false,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .heartbeat = fd(2, .{ .scalar = .bool }),
            .records = fd(3, .{ .scalar = .uint32 }),
            .history_return_max = fd(4, .{ .scalar = .uint32 }),
            .history_return_window = fd(5, .{ .scalar = .uint32 }),
            .is_server = fd(6, .{ .scalar = .bool }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Preferences for the RangeTestModule
    pub const RangeTestConfig = struct {
        enabled: bool = false,
        sender: u32 = 0,
        save: bool = false,
        clear_on_reboot: bool = false,

        pub const _desc_table = .{
            .enabled = fd(1, .{ .scalar = .bool }),
            .sender = fd(2, .{ .scalar = .uint32 }),
            .save = fd(3, .{ .scalar = .bool }),
            .clear_on_reboot = fd(4, .{ .scalar = .bool }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Configuration for both device and environment metrics
    pub const TelemetryConfig = struct {
        device_update_interval: u32 = 0,
        environment_update_interval: u32 = 0,
        environment_measurement_enabled: bool = false,
        environment_screen_enabled: bool = false,
        environment_display_fahrenheit: bool = false,
        air_quality_enabled: bool = false,
        air_quality_interval: u32 = 0,
        power_measurement_enabled: bool = false,
        power_update_interval: u32 = 0,
        power_screen_enabled: bool = false,
        health_measurement_enabled: bool = false,
        health_update_interval: u32 = 0,
        health_screen_enabled: bool = false,
        device_telemetry_enabled: bool = false,
        air_quality_screen_enabled: bool = false,

        pub const _desc_table = .{
            .device_update_interval = fd(1, .{ .scalar = .uint32 }),
            .environment_update_interval = fd(2, .{ .scalar = .uint32 }),
            .environment_measurement_enabled = fd(3, .{ .scalar = .bool }),
            .environment_screen_enabled = fd(4, .{ .scalar = .bool }),
            .environment_display_fahrenheit = fd(5, .{ .scalar = .bool }),
            .air_quality_enabled = fd(6, .{ .scalar = .bool }),
            .air_quality_interval = fd(7, .{ .scalar = .uint32 }),
            .power_measurement_enabled = fd(8, .{ .scalar = .bool }),
            .power_update_interval = fd(9, .{ .scalar = .uint32 }),
            .power_screen_enabled = fd(10, .{ .scalar = .bool }),
            .health_measurement_enabled = fd(11, .{ .scalar = .bool }),
            .health_update_interval = fd(12, .{ .scalar = .uint32 }),
            .health_screen_enabled = fd(13, .{ .scalar = .bool }),
            .device_telemetry_enabled = fd(14, .{ .scalar = .bool }),
            .air_quality_screen_enabled = fd(15, .{ .scalar = .bool }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Canned Messages Module Config
    pub const CannedMessageConfig = struct {
        rotary1_enabled: bool = false,
        inputbroker_pin_a: u32 = 0,
        inputbroker_pin_b: u32 = 0,
        inputbroker_pin_press: u32 = 0,
        inputbroker_event_cw: ModuleConfig.CannedMessageConfig.InputEventChar = @enumFromInt(0),
        inputbroker_event_ccw: ModuleConfig.CannedMessageConfig.InputEventChar = @enumFromInt(0),
        inputbroker_event_press: ModuleConfig.CannedMessageConfig.InputEventChar = @enumFromInt(0),
        updown1_enabled: bool = false,
        enabled: bool = false,
        allow_input_source: []const u8 = &.{},
        send_bell: bool = false,

        pub const _desc_table = .{
            .rotary1_enabled = fd(1, .{ .scalar = .bool }),
            .inputbroker_pin_a = fd(2, .{ .scalar = .uint32 }),
            .inputbroker_pin_b = fd(3, .{ .scalar = .uint32 }),
            .inputbroker_pin_press = fd(4, .{ .scalar = .uint32 }),
            .inputbroker_event_cw = fd(5, .@"enum"),
            .inputbroker_event_ccw = fd(6, .@"enum"),
            .inputbroker_event_press = fd(7, .@"enum"),
            .updown1_enabled = fd(8, .{ .scalar = .bool }),
            .enabled = fd(9, .{ .scalar = .bool }),
            .allow_input_source = fd(10, .{ .scalar = .string }),
            .send_bell = fd(11, .{ .scalar = .bool }),
        };

        ///
        /// TODO: REPLACE
        pub const InputEventChar = enum(i32) {
            NONE = 0,
            UP = 17,
            DOWN = 18,
            LEFT = 19,
            RIGHT = 20,
            SELECT = 10,
            BACK = 27,
            CANCEL = 24,
            _,
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// Ambient Lighting Module - Settings for control of onboard LEDs to allow users to adjust the brightness levels and respective color levels.
    /// Initially created for the RAK14001 RGB LED module.
    pub const AmbientLightingConfig = struct {
        led_state: bool = false,
        current: u32 = 0,
        red: u32 = 0,
        green: u32 = 0,
        blue: u32 = 0,

        pub const _desc_table = .{
            .led_state = fd(1, .{ .scalar = .bool }),
            .current = fd(2, .{ .scalar = .uint32 }),
            .red = fd(3, .{ .scalar = .uint32 }),
            .green = fd(4, .{ .scalar = .uint32 }),
            .blue = fd(5, .{ .scalar = .uint32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// StatusMessage config - Allows setting a status message for a node to periodically rebroadcast
    pub const StatusMessageConfig = struct {
        node_status: []const u8 = &.{},

        pub const _desc_table = .{
            .node_status = fd(1, .{ .scalar = .string }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    ///
    /// TAK team/role configuration
    pub const TAKConfig = struct {
        team: Team = @enumFromInt(0),
        role: MemberRole = @enumFromInt(0),

        pub const _desc_table = .{
            .team = fd(1, .@"enum"),
            .role = fd(2, .@"enum"),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// A GPIO pin definition for remote hardware module
pub const RemoteHardwarePin = struct {
    gpio_pin: u32 = 0,
    name: []const u8 = &.{},
    type: RemoteHardwarePinType = @enumFromInt(0),

    pub const _desc_table = .{
        .gpio_pin = fd(1, .{ .scalar = .uint32 }),
        .name = fd(2, .{ .scalar = .string }),
        .type = fd(3, .@"enum"),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// For any new 'apps' that run on the device or via sister apps on phones/PCs they should pick and use a
/// unique 'portnum' for their application.
/// If you are making a new app using meshtastic, please send in a pull request to add your 'portnum' to this
/// master table.
/// PortNums should be assigned in the following range:
/// 0-63   Core Meshtastic use, do not use for third party apps
/// 64-127 Registered 3rd party apps, send in a pull request that adds a new entry to portnums.proto to  register your application
/// 256-511 Use one of these portnums for your private applications that you don't want to register publically
/// All other values are reserved.
/// Note: This was formerly a Type enum named 'typ' with the same id #
/// We have change to this 'portnum' based scheme for specifying app handlers for particular payloads.
/// This change is backwards compatible by treating the legacy OPAQUE/CLEAR_TEXT values identically.
pub const PortNum = enum(i32) {
    UNKNOWN_APP = 0,
    TEXT_MESSAGE_APP = 1,
    REMOTE_HARDWARE_APP = 2,
    POSITION_APP = 3,
    NODEINFO_APP = 4,
    ROUTING_APP = 5,
    ADMIN_APP = 6,
    TEXT_MESSAGE_COMPRESSED_APP = 7,
    WAYPOINT_APP = 8,
    AUDIO_APP = 9,
    DETECTION_SENSOR_APP = 10,
    ALERT_APP = 11,
    KEY_VERIFICATION_APP = 12,
    REPLY_APP = 32,
    IP_TUNNEL_APP = 33,
    PAXCOUNTER_APP = 34,
    STORE_FORWARD_PLUSPLUS_APP = 35,
    NODE_STATUS_APP = 36,
    SERIAL_APP = 64,
    STORE_FORWARD_APP = 65,
    RANGE_TEST_APP = 66,
    TELEMETRY_APP = 67,
    ZPS_APP = 68,
    SIMULATOR_APP = 69,
    TRACEROUTE_APP = 70,
    NEIGHBORINFO_APP = 71,
    ATAK_PLUGIN = 72,
    MAP_REPORT_APP = 73,
    POWERSTRESS_APP = 74,
    RETICULUM_TUNNEL_APP = 76,
    CAYENNE_APP = 77,
    PRIVATE_APP = 256,
    ATAK_FORWARDER = 257,
    MAX = 511,
    _,
};

///
/// Supported I2C Sensors for telemetry in Meshtastic
pub const TelemetrySensorType = enum(i32) {
    SENSOR_UNSET = 0,
    BME280 = 1,
    BME680 = 2,
    MCP9808 = 3,
    INA260 = 4,
    INA219 = 5,
    BMP280 = 6,
    SHTC3 = 7,
    LPS22 = 8,
    QMC6310 = 9,
    QMI8658 = 10,
    QMC5883L = 11,
    SHT31 = 12,
    PMSA003I = 13,
    INA3221 = 14,
    BMP085 = 15,
    RCWL9620 = 16,
    SHT4X = 17,
    VEML7700 = 18,
    MLX90632 = 19,
    OPT3001 = 20,
    LTR390UV = 21,
    TSL25911FN = 22,
    AHT10 = 23,
    DFROBOT_LARK = 24,
    NAU7802 = 25,
    BMP3XX = 26,
    ICM20948 = 27,
    MAX17048 = 28,
    CUSTOM_SENSOR = 29,
    MAX30102 = 30,
    MLX90614 = 31,
    SCD4X = 32,
    RADSENS = 33,
    INA226 = 34,
    DFROBOT_RAIN = 35,
    DPS310 = 36,
    RAK12035 = 37,
    MAX17261 = 38,
    PCT2075 = 39,
    ADS1X15 = 40,
    ADS1X15_ALT = 41,
    SFA30 = 42,
    SEN5X = 43,
    TSL2561 = 44,
    BH1750 = 45,
    HDC1080 = 46,
    SHT21 = 47,
    STC31 = 48,
    SCD30 = 49,
    _,
};

///
/// Key native device metrics such as battery level
pub const DeviceMetrics = struct {
    battery_level: ?u32 = null,
    voltage: ?f32 = null,
    channel_utilization: ?f32 = null,
    air_util_tx: ?f32 = null,
    uptime_seconds: ?u32 = null,

    pub const _desc_table = .{
        .battery_level = fd(1, .{ .scalar = .uint32 }),
        .voltage = fd(2, .{ .scalar = .float }),
        .channel_utilization = fd(3, .{ .scalar = .float }),
        .air_util_tx = fd(4, .{ .scalar = .float }),
        .uptime_seconds = fd(5, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Weather station or other environmental metrics
pub const EnvironmentMetrics = struct {
    temperature: ?f32 = null,
    relative_humidity: ?f32 = null,
    barometric_pressure: ?f32 = null,
    gas_resistance: ?f32 = null,
    voltage: ?f32 = null,
    current: ?f32 = null,
    iaq: ?u32 = null,
    distance: ?f32 = null,
    lux: ?f32 = null,
    white_lux: ?f32 = null,
    ir_lux: ?f32 = null,
    uv_lux: ?f32 = null,
    wind_direction: ?u32 = null,
    wind_speed: ?f32 = null,
    weight: ?f32 = null,
    wind_gust: ?f32 = null,
    wind_lull: ?f32 = null,
    radiation: ?f32 = null,
    rainfall_1h: ?f32 = null,
    rainfall_24h: ?f32 = null,
    soil_moisture: ?u32 = null,
    soil_temperature: ?f32 = null,

    pub const _desc_table = .{
        .temperature = fd(1, .{ .scalar = .float }),
        .relative_humidity = fd(2, .{ .scalar = .float }),
        .barometric_pressure = fd(3, .{ .scalar = .float }),
        .gas_resistance = fd(4, .{ .scalar = .float }),
        .voltage = fd(5, .{ .scalar = .float }),
        .current = fd(6, .{ .scalar = .float }),
        .iaq = fd(7, .{ .scalar = .uint32 }),
        .distance = fd(8, .{ .scalar = .float }),
        .lux = fd(9, .{ .scalar = .float }),
        .white_lux = fd(10, .{ .scalar = .float }),
        .ir_lux = fd(11, .{ .scalar = .float }),
        .uv_lux = fd(12, .{ .scalar = .float }),
        .wind_direction = fd(13, .{ .scalar = .uint32 }),
        .wind_speed = fd(14, .{ .scalar = .float }),
        .weight = fd(15, .{ .scalar = .float }),
        .wind_gust = fd(16, .{ .scalar = .float }),
        .wind_lull = fd(17, .{ .scalar = .float }),
        .radiation = fd(18, .{ .scalar = .float }),
        .rainfall_1h = fd(19, .{ .scalar = .float }),
        .rainfall_24h = fd(20, .{ .scalar = .float }),
        .soil_moisture = fd(21, .{ .scalar = .uint32 }),
        .soil_temperature = fd(22, .{ .scalar = .float }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Power Metrics (voltage / current / etc)
pub const PowerMetrics = struct {
    ch1_voltage: ?f32 = null,
    ch1_current: ?f32 = null,
    ch2_voltage: ?f32 = null,
    ch2_current: ?f32 = null,
    ch3_voltage: ?f32 = null,
    ch3_current: ?f32 = null,
    ch4_voltage: ?f32 = null,
    ch4_current: ?f32 = null,
    ch5_voltage: ?f32 = null,
    ch5_current: ?f32 = null,
    ch6_voltage: ?f32 = null,
    ch6_current: ?f32 = null,
    ch7_voltage: ?f32 = null,
    ch7_current: ?f32 = null,
    ch8_voltage: ?f32 = null,
    ch8_current: ?f32 = null,

    pub const _desc_table = .{
        .ch1_voltage = fd(1, .{ .scalar = .float }),
        .ch1_current = fd(2, .{ .scalar = .float }),
        .ch2_voltage = fd(3, .{ .scalar = .float }),
        .ch2_current = fd(4, .{ .scalar = .float }),
        .ch3_voltage = fd(5, .{ .scalar = .float }),
        .ch3_current = fd(6, .{ .scalar = .float }),
        .ch4_voltage = fd(7, .{ .scalar = .float }),
        .ch4_current = fd(8, .{ .scalar = .float }),
        .ch5_voltage = fd(9, .{ .scalar = .float }),
        .ch5_current = fd(10, .{ .scalar = .float }),
        .ch6_voltage = fd(11, .{ .scalar = .float }),
        .ch6_current = fd(12, .{ .scalar = .float }),
        .ch7_voltage = fd(13, .{ .scalar = .float }),
        .ch7_current = fd(14, .{ .scalar = .float }),
        .ch8_voltage = fd(15, .{ .scalar = .float }),
        .ch8_current = fd(16, .{ .scalar = .float }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Air quality metrics
pub const AirQualityMetrics = struct {
    pm10_standard: ?u32 = null,
    pm25_standard: ?u32 = null,
    pm100_standard: ?u32 = null,
    pm10_environmental: ?u32 = null,
    pm25_environmental: ?u32 = null,
    pm100_environmental: ?u32 = null,
    particles_03um: ?u32 = null,
    particles_05um: ?u32 = null,
    particles_10um: ?u32 = null,
    particles_25um: ?u32 = null,
    particles_50um: ?u32 = null,
    particles_100um: ?u32 = null,
    co2: ?u32 = null,
    co2_temperature: ?f32 = null,
    co2_humidity: ?f32 = null,
    form_formaldehyde: ?f32 = null,
    form_humidity: ?f32 = null,
    form_temperature: ?f32 = null,
    pm40_standard: ?u32 = null,
    particles_40um: ?u32 = null,
    pm_temperature: ?f32 = null,
    pm_humidity: ?f32 = null,
    pm_voc_idx: ?f32 = null,
    pm_nox_idx: ?f32 = null,
    particles_tps: ?f32 = null,

    pub const _desc_table = .{
        .pm10_standard = fd(1, .{ .scalar = .uint32 }),
        .pm25_standard = fd(2, .{ .scalar = .uint32 }),
        .pm100_standard = fd(3, .{ .scalar = .uint32 }),
        .pm10_environmental = fd(4, .{ .scalar = .uint32 }),
        .pm25_environmental = fd(5, .{ .scalar = .uint32 }),
        .pm100_environmental = fd(6, .{ .scalar = .uint32 }),
        .particles_03um = fd(7, .{ .scalar = .uint32 }),
        .particles_05um = fd(8, .{ .scalar = .uint32 }),
        .particles_10um = fd(9, .{ .scalar = .uint32 }),
        .particles_25um = fd(10, .{ .scalar = .uint32 }),
        .particles_50um = fd(11, .{ .scalar = .uint32 }),
        .particles_100um = fd(12, .{ .scalar = .uint32 }),
        .co2 = fd(13, .{ .scalar = .uint32 }),
        .co2_temperature = fd(14, .{ .scalar = .float }),
        .co2_humidity = fd(15, .{ .scalar = .float }),
        .form_formaldehyde = fd(16, .{ .scalar = .float }),
        .form_humidity = fd(17, .{ .scalar = .float }),
        .form_temperature = fd(18, .{ .scalar = .float }),
        .pm40_standard = fd(19, .{ .scalar = .uint32 }),
        .particles_40um = fd(20, .{ .scalar = .uint32 }),
        .pm_temperature = fd(21, .{ .scalar = .float }),
        .pm_humidity = fd(22, .{ .scalar = .float }),
        .pm_voc_idx = fd(23, .{ .scalar = .float }),
        .pm_nox_idx = fd(24, .{ .scalar = .float }),
        .particles_tps = fd(25, .{ .scalar = .float }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Local device mesh statistics
pub const LocalStats = struct {
    uptime_seconds: u32 = 0,
    channel_utilization: f32 = 0,
    air_util_tx: f32 = 0,
    num_packets_tx: u32 = 0,
    num_packets_rx: u32 = 0,
    num_packets_rx_bad: u32 = 0,
    num_online_nodes: u32 = 0,
    num_total_nodes: u32 = 0,
    num_rx_dupe: u32 = 0,
    num_tx_relay: u32 = 0,
    num_tx_relay_canceled: u32 = 0,
    heap_total_bytes: u32 = 0,
    heap_free_bytes: u32 = 0,
    num_tx_dropped: u32 = 0,
    noise_floor: i32 = 0,

    pub const _desc_table = .{
        .uptime_seconds = fd(1, .{ .scalar = .uint32 }),
        .channel_utilization = fd(2, .{ .scalar = .float }),
        .air_util_tx = fd(3, .{ .scalar = .float }),
        .num_packets_tx = fd(4, .{ .scalar = .uint32 }),
        .num_packets_rx = fd(5, .{ .scalar = .uint32 }),
        .num_packets_rx_bad = fd(6, .{ .scalar = .uint32 }),
        .num_online_nodes = fd(7, .{ .scalar = .uint32 }),
        .num_total_nodes = fd(8, .{ .scalar = .uint32 }),
        .num_rx_dupe = fd(9, .{ .scalar = .uint32 }),
        .num_tx_relay = fd(10, .{ .scalar = .uint32 }),
        .num_tx_relay_canceled = fd(11, .{ .scalar = .uint32 }),
        .heap_total_bytes = fd(12, .{ .scalar = .uint32 }),
        .heap_free_bytes = fd(13, .{ .scalar = .uint32 }),
        .num_tx_dropped = fd(14, .{ .scalar = .uint32 }),
        .noise_floor = fd(15, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Traffic management statistics for mesh network optimization
pub const TrafficManagementStats = struct {
    packets_inspected: u32 = 0,
    position_dedup_drops: u32 = 0,
    nodeinfo_cache_hits: u32 = 0,
    rate_limit_drops: u32 = 0,
    unknown_packet_drops: u32 = 0,
    hop_exhausted_packets: u32 = 0,
    router_hops_preserved: u32 = 0,

    pub const _desc_table = .{
        .packets_inspected = fd(1, .{ .scalar = .uint32 }),
        .position_dedup_drops = fd(2, .{ .scalar = .uint32 }),
        .nodeinfo_cache_hits = fd(3, .{ .scalar = .uint32 }),
        .rate_limit_drops = fd(4, .{ .scalar = .uint32 }),
        .unknown_packet_drops = fd(5, .{ .scalar = .uint32 }),
        .hop_exhausted_packets = fd(6, .{ .scalar = .uint32 }),
        .router_hops_preserved = fd(7, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Health telemetry metrics
pub const HealthMetrics = struct {
    heart_bpm: ?u32 = null,
    spO2: ?u32 = null,
    temperature: ?f32 = null,

    pub const _desc_table = .{
        .heart_bpm = fd(1, .{ .scalar = .uint32 }),
        .spO2 = fd(2, .{ .scalar = .uint32 }),
        .temperature = fd(3, .{ .scalar = .float }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Linux host metrics
pub const HostMetrics = struct {
    uptime_seconds: u32 = 0,
    freemem_bytes: u64 = 0,
    diskfree1_bytes: u64 = 0,
    diskfree2_bytes: ?u64 = null,
    diskfree3_bytes: ?u64 = null,
    load1: u32 = 0,
    load5: u32 = 0,
    load15: u32 = 0,
    user_string: ?[]const u8 = null,

    pub const _desc_table = .{
        .uptime_seconds = fd(1, .{ .scalar = .uint32 }),
        .freemem_bytes = fd(2, .{ .scalar = .uint64 }),
        .diskfree1_bytes = fd(3, .{ .scalar = .uint64 }),
        .diskfree2_bytes = fd(4, .{ .scalar = .uint64 }),
        .diskfree3_bytes = fd(5, .{ .scalar = .uint64 }),
        .load1 = fd(6, .{ .scalar = .uint32 }),
        .load5 = fd(7, .{ .scalar = .uint32 }),
        .load15 = fd(8, .{ .scalar = .uint32 }),
        .user_string = fd(9, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Types of Measurements the telemetry module is equipped to handle
pub const Telemetry = struct {
    time: u32 = 0,
    variant: ?variant_union = null,

    pub const _variant_case = enum {
        device_metrics,
        environment_metrics,
        air_quality_metrics,
        power_metrics,
        local_stats,
        health_metrics,
        host_metrics,
        traffic_management_stats,
    };
    pub const variant_union = union(_variant_case) {
        device_metrics: DeviceMetrics,
        environment_metrics: EnvironmentMetrics,
        air_quality_metrics: AirQualityMetrics,
        power_metrics: PowerMetrics,
        local_stats: LocalStats,
        health_metrics: HealthMetrics,
        host_metrics: HostMetrics,
        traffic_management_stats: TrafficManagementStats,
        pub const _desc_table = .{
            .device_metrics = fd(2, .submessage),
            .environment_metrics = fd(3, .submessage),
            .air_quality_metrics = fd(4, .submessage),
            .power_metrics = fd(5, .submessage),
            .local_stats = fd(6, .submessage),
            .health_metrics = fd(7, .submessage),
            .host_metrics = fd(8, .submessage),
            .traffic_management_stats = fd(9, .submessage),
        };
    };

    pub const _desc_table = .{
        .time = fd(1, .{ .scalar = .fixed32 }),
        .variant = fd(null, .{ .oneof = variant_union }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// NAU7802 Telemetry configuration, for saving to flash
pub const Nau7802Config = struct {
    zeroOffset: i32 = 0,
    calibrationFactor: f32 = 0,

    pub const _desc_table = .{
        .zeroOffset = fd(1, .{ .scalar = .int32 }),
        .calibrationFactor = fd(2, .{ .scalar = .float }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// SEN5X State, for saving to flash
pub const SEN5XState = struct {
    last_cleaning_time: u32 = 0,
    last_cleaning_valid: bool = false,
    one_shot_mode: bool = false,
    voc_state_time: ?u32 = null,
    voc_state_valid: ?bool = null,
    voc_state_array: ?u64 = null,

    pub const _desc_table = .{
        .last_cleaning_time = fd(1, .{ .scalar = .uint32 }),
        .last_cleaning_valid = fd(2, .{ .scalar = .bool }),
        .one_shot_mode = fd(3, .{ .scalar = .bool }),
        .voc_state_time = fd(4, .{ .scalar = .uint32 }),
        .voc_state_valid = fd(5, .{ .scalar = .bool }),
        .voc_state_array = fd(6, .{ .scalar = .fixed64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const XModem = struct {
    control: XModem.Control = @enumFromInt(0),
    seq: u32 = 0,
    crc16: u32 = 0,
    buffer: []const u8 = &.{},

    pub const _desc_table = .{
        .control = fd(1, .@"enum"),
        .seq = fd(2, .{ .scalar = .uint32 }),
        .crc16 = fd(3, .{ .scalar = .uint32 }),
        .buffer = fd(4, .{ .scalar = .bytes }),
    };

    pub const Control = enum(i32) {
        NUL = 0,
        SOH = 1,
        STX = 2,
        EOT = 4,
        ACK = 6,
        NAK = 21,
        CAN = 24,
        CTRLZ = 26,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Note: these enum names must EXACTLY match the string used in the device
/// bin/build-all.sh script.
/// Because they will be used to find firmware filenames in the android app for OTA updates.
/// To match the old style filenames, _ is converted to -, p is converted to .
pub const HardwareModel = enum(i32) {
    UNSET = 0,
    TLORA_V2 = 1,
    TLORA_V1 = 2,
    TLORA_V2_1_1P6 = 3,
    TBEAM = 4,
    HELTEC_V2_0 = 5,
    TBEAM_V0P7 = 6,
    T_ECHO = 7,
    TLORA_V1_1P3 = 8,
    RAK4631 = 9,
    HELTEC_V2_1 = 10,
    HELTEC_V1 = 11,
    LILYGO_TBEAM_S3_CORE = 12,
    RAK11200 = 13,
    NANO_G1 = 14,
    TLORA_V2_1_1P8 = 15,
    TLORA_T3_S3 = 16,
    NANO_G1_EXPLORER = 17,
    NANO_G2_ULTRA = 18,
    LORA_TYPE = 19,
    WIPHONE = 20,
    WIO_WM1110 = 21,
    RAK2560 = 22,
    HELTEC_HRU_3601 = 23,
    HELTEC_WIRELESS_BRIDGE = 24,
    STATION_G1 = 25,
    RAK11310 = 26,
    SENSELORA_RP2040 = 27,
    SENSELORA_S3 = 28,
    CANARYONE = 29,
    RP2040_LORA = 30,
    STATION_G2 = 31,
    LORA_RELAY_V1 = 32,
    T_ECHO_PLUS = 33,
    PPR = 34,
    GENIEBLOCKS = 35,
    NRF52_UNKNOWN = 36,
    PORTDUINO = 37,
    ANDROID_SIM = 38,
    DIY_V1 = 39,
    NRF52840_PCA10059 = 40,
    DR_DEV = 41,
    M5STACK = 42,
    HELTEC_V3 = 43,
    HELTEC_WSL_V3 = 44,
    BETAFPV_2400_TX = 45,
    BETAFPV_900_NANO_TX = 46,
    RPI_PICO = 47,
    HELTEC_WIRELESS_TRACKER = 48,
    HELTEC_WIRELESS_PAPER = 49,
    T_DECK = 50,
    T_WATCH_S3 = 51,
    PICOMPUTER_S3 = 52,
    HELTEC_HT62 = 53,
    EBYTE_ESP32_S3 = 54,
    ESP32_S3_PICO = 55,
    CHATTER_2 = 56,
    HELTEC_WIRELESS_PAPER_V1_0 = 57,
    HELTEC_WIRELESS_TRACKER_V1_0 = 58,
    UNPHONE = 59,
    TD_LORAC = 60,
    CDEBYTE_EORA_S3 = 61,
    TWC_MESH_V4 = 62,
    NRF52_PROMICRO_DIY = 63,
    RADIOMASTER_900_BANDIT_NANO = 64,
    HELTEC_CAPSULE_SENSOR_V3 = 65,
    HELTEC_VISION_MASTER_T190 = 66,
    HELTEC_VISION_MASTER_E213 = 67,
    HELTEC_VISION_MASTER_E290 = 68,
    HELTEC_MESH_NODE_T114 = 69,
    SENSECAP_INDICATOR = 70,
    TRACKER_T1000_E = 71,
    RAK3172 = 72,
    WIO_E5 = 73,
    RADIOMASTER_900_BANDIT = 74,
    ME25LS01_4Y10TD = 75,
    RP2040_FEATHER_RFM95 = 76,
    M5STACK_COREBASIC = 77,
    M5STACK_CORE2 = 78,
    RPI_PICO2 = 79,
    M5STACK_CORES3 = 80,
    SEEED_XIAO_S3 = 81,
    MS24SF1 = 82,
    TLORA_C6 = 83,
    WISMESH_TAP = 84,
    ROUTASTIC = 85,
    MESH_TAB = 86,
    MESHLINK = 87,
    XIAO_NRF52_KIT = 88,
    THINKNODE_M1 = 89,
    THINKNODE_M2 = 90,
    T_ETH_ELITE = 91,
    HELTEC_SENSOR_HUB = 92,
    MUZI_BASE = 93,
    HELTEC_MESH_POCKET = 94,
    SEEED_SOLAR_NODE = 95,
    NOMADSTAR_METEOR_PRO = 96,
    CROWPANEL = 97,
    LINK_32 = 98,
    SEEED_WIO_TRACKER_L1 = 99,
    SEEED_WIO_TRACKER_L1_EINK = 100,
    MUZI_R1_NEO = 101,
    T_DECK_PRO = 102,
    T_LORA_PAGER = 103,
    M5STACK_RESERVED = 104,
    WISMESH_TAG = 105,
    RAK3312 = 106,
    THINKNODE_M5 = 107,
    HELTEC_MESH_SOLAR = 108,
    T_ECHO_LITE = 109,
    HELTEC_V4 = 110,
    M5STACK_C6L = 111,
    M5STACK_CARDPUTER_ADV = 112,
    HELTEC_WIRELESS_TRACKER_V2 = 113,
    T_WATCH_ULTRA = 114,
    THINKNODE_M3 = 115,
    WISMESH_TAP_V2 = 116,
    RAK3401 = 117,
    RAK6421 = 118,
    THINKNODE_M4 = 119,
    THINKNODE_M6 = 120,
    MESHSTICK_1262 = 121,
    TBEAM_1_WATT = 122,
    T5_S3_EPAPER_PRO = 123,
    TBEAM_BPF = 124,
    MINI_EPAPER_S3 = 125,
    PRIVATE_HW = 255,
    _,
};

///
/// Shared constants between device and phone
pub const Constants = enum(i32) {
    ZERO = 0,
    DATA_PAYLOAD_LEN = 233,
    _,
};

///
/// Error codes for critical errors
/// The device might report these fault codes on the screen.
/// If you encounter a fault code, please post on the meshtastic.discourse.group
/// and we'll try to help.
pub const CriticalErrorCode = enum(i32) {
    NONE = 0,
    TX_WATCHDOG = 1,
    SLEEP_ENTER_WAIT = 2,
    NO_RADIO = 3,
    UNSPECIFIED = 4,
    UBLOX_UNIT_FAILED = 5,
    NO_AXP192 = 6,
    INVALID_RADIO_SETTING = 7,
    TRANSMIT_FAILED = 8,
    BROWNOUT = 9,
    SX1262_FAILURE = 10,
    RADIO_SPI_BUG = 11,
    FLASH_CORRUPTION_RECOVERABLE = 12,
    FLASH_CORRUPTION_UNRECOVERABLE = 13,
    _,
};

///
/// Enum to indicate to clients whether this firmware is a special firmware build, like an event.
/// The first 16 values are reserved for non-event special firmwares, like the Smart Citizen use case.
pub const FirmwareEdition = enum(i32) {
    VANILLA = 0,
    SMART_CITIZEN = 1,
    OPEN_SAUCE = 16,
    DEFCON = 17,
    BURNING_MAN = 18,
    HAMVENTION = 19,
    DIY_EDITION = 127,
    _,
};

///
/// Enum for modules excluded from a device's configuration.
/// Each value represents a ModuleConfigType that can be toggled as excluded
/// by setting its corresponding bit in the `excluded_modules` bitmask field.
pub const ExcludedModules = enum(i32) {
    EXCLUDED_NONE = 0,
    MQTT_CONFIG = 1,
    SERIAL_CONFIG = 2,
    EXTNOTIF_CONFIG = 4,
    STOREFORWARD_CONFIG = 8,
    RANGETEST_CONFIG = 16,
    TELEMETRY_CONFIG = 32,
    CANNEDMSG_CONFIG = 64,
    AUDIO_CONFIG = 128,
    REMOTEHARDWARE_CONFIG = 256,
    NEIGHBORINFO_CONFIG = 512,
    AMBIENTLIGHTING_CONFIG = 1024,
    DETECTIONSENSOR_CONFIG = 2048,
    PAXCOUNTER_CONFIG = 4096,
    BLUETOOTH_CONFIG = 8192,
    NETWORK_CONFIG = 16384,
    _,
};

///
/// A GPS Position
pub const Position = struct {
    latitude_i: ?i32 = null,
    longitude_i: ?i32 = null,
    altitude: ?i32 = null,
    time: u32 = 0,
    location_source: Position.LocSource = @enumFromInt(0),
    altitude_source: Position.AltSource = @enumFromInt(0),
    timestamp: u32 = 0,
    timestamp_millis_adjust: i32 = 0,
    altitude_hae: ?i32 = null,
    altitude_geoidal_separation: ?i32 = null,
    PDOP: u32 = 0,
    HDOP: u32 = 0,
    VDOP: u32 = 0,
    gps_accuracy: u32 = 0,
    ground_speed: ?u32 = null,
    ground_track: ?u32 = null,
    fix_quality: u32 = 0,
    fix_type: u32 = 0,
    sats_in_view: u32 = 0,
    sensor_id: u32 = 0,
    next_update: u32 = 0,
    seq_number: u32 = 0,
    precision_bits: u32 = 0,

    pub const _desc_table = .{
        .latitude_i = fd(1, .{ .scalar = .sfixed32 }),
        .longitude_i = fd(2, .{ .scalar = .sfixed32 }),
        .altitude = fd(3, .{ .scalar = .int32 }),
        .time = fd(4, .{ .scalar = .fixed32 }),
        .location_source = fd(5, .@"enum"),
        .altitude_source = fd(6, .@"enum"),
        .timestamp = fd(7, .{ .scalar = .fixed32 }),
        .timestamp_millis_adjust = fd(8, .{ .scalar = .int32 }),
        .altitude_hae = fd(9, .{ .scalar = .sint32 }),
        .altitude_geoidal_separation = fd(10, .{ .scalar = .sint32 }),
        .PDOP = fd(11, .{ .scalar = .uint32 }),
        .HDOP = fd(12, .{ .scalar = .uint32 }),
        .VDOP = fd(13, .{ .scalar = .uint32 }),
        .gps_accuracy = fd(14, .{ .scalar = .uint32 }),
        .ground_speed = fd(15, .{ .scalar = .uint32 }),
        .ground_track = fd(16, .{ .scalar = .uint32 }),
        .fix_quality = fd(17, .{ .scalar = .uint32 }),
        .fix_type = fd(18, .{ .scalar = .uint32 }),
        .sats_in_view = fd(19, .{ .scalar = .uint32 }),
        .sensor_id = fd(20, .{ .scalar = .uint32 }),
        .next_update = fd(21, .{ .scalar = .uint32 }),
        .seq_number = fd(22, .{ .scalar = .uint32 }),
        .precision_bits = fd(23, .{ .scalar = .uint32 }),
    };

    ///
    /// How the location was acquired: manual, onboard GPS, external (EUD) GPS
    pub const LocSource = enum(i32) {
        LOC_UNSET = 0,
        LOC_MANUAL = 1,
        LOC_INTERNAL = 2,
        LOC_EXTERNAL = 3,
        _,
    };

    ///
    /// How the altitude was acquired: manual, GPS int/ext, etc
    /// Default: same as location_source if present
    pub const AltSource = enum(i32) {
        ALT_UNSET = 0,
        ALT_MANUAL = 1,
        ALT_INTERNAL = 2,
        ALT_EXTERNAL = 3,
        ALT_BAROMETRIC = 4,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Broadcast when a newly powered mesh node wants to find a node num it can use
/// Sent from the phone over bluetooth to set the user id for the owner of this node.
/// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
/// The algorithm is as follows:
/// when a node starts up, it broadcasts their user and the normal flow is for all
/// other nodes to reply with their User as well (so the new node can build its nodedb)
/// If a node ever receives a User (not just the first broadcast) message where
/// the sender node number equals our node number, that indicates a collision has
/// occurred and the following steps should happen:
/// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
/// new User who just tried to sign in: it gets to keep its nodenum.
/// We send a broadcast message of OUR User (we use a broadcast so that the other node can
/// receive our message, considering we have the same id - it also serves to let
/// observers correct their nodedb) - this case is rare so it should be okay.
/// If any node receives a User where the macaddr is GTE than their local macaddr,
/// they have been vetoed and should pick a new random nodenum (filtering against
/// whatever it knows about the nodedb) and rebroadcast their User.
/// A few nodenums are reserved and will never be requested:
/// 0xff - broadcast
/// 0 through 3 - for future use
pub const User = struct {
    id: []const u8 = &.{},
    long_name: []const u8 = &.{},
    short_name: []const u8 = &.{},
    macaddr: []const u8 = &.{},
    hw_model: HardwareModel = @enumFromInt(0),
    is_licensed: bool = false,
    role: Config.DeviceConfig.Role = @enumFromInt(0),
    public_key: []const u8 = &.{},
    is_unmessagable: ?bool = null,

    pub const _desc_table = .{
        .id = fd(1, .{ .scalar = .string }),
        .long_name = fd(2, .{ .scalar = .string }),
        .short_name = fd(3, .{ .scalar = .string }),
        .macaddr = fd(4, .{ .scalar = .bytes }),
        .hw_model = fd(5, .@"enum"),
        .is_licensed = fd(6, .{ .scalar = .bool }),
        .role = fd(7, .@"enum"),
        .public_key = fd(8, .{ .scalar = .bytes }),
        .is_unmessagable = fd(9, .{ .scalar = .bool }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// A message used in a traceroute
pub const RouteDiscovery = struct {
    route: std.ArrayListUnmanaged(u32) = .empty,
    snr_towards: std.ArrayListUnmanaged(i32) = .empty,
    route_back: std.ArrayListUnmanaged(u32) = .empty,
    snr_back: std.ArrayListUnmanaged(i32) = .empty,

    pub const _desc_table = .{
        .route = fd(1, .{ .packed_repeated = .{ .scalar = .fixed32 } }),
        .snr_towards = fd(2, .{ .packed_repeated = .{ .scalar = .int32 } }),
        .route_back = fd(3, .{ .packed_repeated = .{ .scalar = .fixed32 } }),
        .snr_back = fd(4, .{ .packed_repeated = .{ .scalar = .int32 } }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// A Routing control Data packet handled by the routing module
pub const Routing = struct {
    variant: ?variant_union = null,

    pub const _variant_case = enum {
        route_request,
        route_reply,
        error_reason,
    };
    pub const variant_union = union(_variant_case) {
        route_request: RouteDiscovery,
        route_reply: RouteDiscovery,
        error_reason: Routing.Error,
        pub const _desc_table = .{
            .route_request = fd(1, .submessage),
            .route_reply = fd(2, .submessage),
            .error_reason = fd(3, .@"enum"),
        };
    };

    pub const _desc_table = .{
        .variant = fd(null, .{ .oneof = variant_union }),
    };

    ///
    /// A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
    /// details on the type of failure).
    pub const Error = enum(i32) {
        NONE = 0,
        NO_ROUTE = 1,
        GOT_NAK = 2,
        TIMEOUT = 3,
        NO_INTERFACE = 4,
        MAX_RETRANSMIT = 5,
        NO_CHANNEL = 6,
        TOO_LARGE = 7,
        NO_RESPONSE = 8,
        DUTY_CYCLE_LIMIT = 9,
        BAD_REQUEST = 32,
        NOT_AUTHORIZED = 33,
        PKI_FAILED = 34,
        PKI_UNKNOWN_PUBKEY = 35,
        ADMIN_BAD_SESSION_KEY = 36,
        ADMIN_PUBLIC_KEY_UNAUTHORIZED = 37,
        RATE_LIMIT_EXCEEDED = 38,
        PKI_SEND_FAIL_PUBLIC_KEY = 39,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// (Formerly called SubPacket)
/// The payload portion fo a packet, this is the actual bytes that are sent
/// inside a radio packet (because from/to are broken out by the comms library)
pub const Data = struct {
    portnum: PortNum = @enumFromInt(0),
    payload: []const u8 = &.{},
    want_response: bool = false,
    dest: u32 = 0,
    source: u32 = 0,
    request_id: u32 = 0,
    reply_id: u32 = 0,
    emoji: u32 = 0,
    bitfield: ?u32 = null,

    pub const _desc_table = .{
        .portnum = fd(1, .@"enum"),
        .payload = fd(2, .{ .scalar = .bytes }),
        .want_response = fd(3, .{ .scalar = .bool }),
        .dest = fd(4, .{ .scalar = .fixed32 }),
        .source = fd(5, .{ .scalar = .fixed32 }),
        .request_id = fd(6, .{ .scalar = .fixed32 }),
        .reply_id = fd(7, .{ .scalar = .fixed32 }),
        .emoji = fd(8, .{ .scalar = .fixed32 }),
        .bitfield = fd(9, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// The actual over-the-mesh message doing KeyVerification
pub const KeyVerification = struct {
    nonce: u64 = 0,
    hash1: []const u8 = &.{},
    hash2: []const u8 = &.{},

    pub const _desc_table = .{
        .nonce = fd(1, .{ .scalar = .uint64 }),
        .hash1 = fd(2, .{ .scalar = .bytes }),
        .hash2 = fd(3, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// The actual over-the-mesh message doing store and forward++
pub const StoreForwardPlusPlus = struct {
    sfpp_message_type: StoreForwardPlusPlus.SFPP_message_type = @enumFromInt(0),
    message_hash: []const u8 = &.{},
    commit_hash: []const u8 = &.{},
    root_hash: []const u8 = &.{},
    message: []const u8 = &.{},
    encapsulated_id: u32 = 0,
    encapsulated_to: u32 = 0,
    encapsulated_from: u32 = 0,
    encapsulated_rxtime: u32 = 0,
    chain_count: u32 = 0,

    pub const _desc_table = .{
        .sfpp_message_type = fd(1, .@"enum"),
        .message_hash = fd(2, .{ .scalar = .bytes }),
        .commit_hash = fd(3, .{ .scalar = .bytes }),
        .root_hash = fd(4, .{ .scalar = .bytes }),
        .message = fd(5, .{ .scalar = .bytes }),
        .encapsulated_id = fd(6, .{ .scalar = .uint32 }),
        .encapsulated_to = fd(7, .{ .scalar = .uint32 }),
        .encapsulated_from = fd(8, .{ .scalar = .uint32 }),
        .encapsulated_rxtime = fd(9, .{ .scalar = .uint32 }),
        .chain_count = fd(10, .{ .scalar = .uint32 }),
    };

    ///
    /// Enum of message types
    pub const SFPP_message_type = enum(i32) {
        CANON_ANNOUNCE = 0,
        CHAIN_QUERY = 1,
        LINK_REQUEST = 3,
        LINK_PROVIDE = 4,
        LINK_PROVIDE_FIRSTHALF = 5,
        LINK_PROVIDE_SECONDHALF = 6,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Waypoint message, used to share arbitrary locations across the mesh
pub const Waypoint = struct {
    id: u32 = 0,
    latitude_i: ?i32 = null,
    longitude_i: ?i32 = null,
    expire: u32 = 0,
    locked_to: u32 = 0,
    name: []const u8 = &.{},
    description: []const u8 = &.{},
    icon: u32 = 0,

    pub const _desc_table = .{
        .id = fd(1, .{ .scalar = .uint32 }),
        .latitude_i = fd(2, .{ .scalar = .sfixed32 }),
        .longitude_i = fd(3, .{ .scalar = .sfixed32 }),
        .expire = fd(4, .{ .scalar = .uint32 }),
        .locked_to = fd(5, .{ .scalar = .uint32 }),
        .name = fd(6, .{ .scalar = .string }),
        .description = fd(7, .{ .scalar = .string }),
        .icon = fd(8, .{ .scalar = .fixed32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Message for node status
pub const StatusMessage = struct {
    status: []const u8 = &.{},

    pub const _desc_table = .{
        .status = fd(1, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// This message will be proxied over the PhoneAPI for the client to deliver to the MQTT server
pub const MqttClientProxyMessage = struct {
    topic: []const u8 = &.{},
    retained: bool = false,
    payload_variant: ?payload_variant_union = null,

    pub const _payload_variant_case = enum {
        data,
        text,
    };
    pub const payload_variant_union = union(_payload_variant_case) {
        data: []const u8,
        text: []const u8,
        pub const _desc_table = .{
            .data = fd(2, .{ .scalar = .bytes }),
            .text = fd(3, .{ .scalar = .string }),
        };
    };

    pub const _desc_table = .{
        .topic = fd(1, .{ .scalar = .string }),
        .retained = fd(4, .{ .scalar = .bool }),
        .payload_variant = fd(null, .{ .oneof = payload_variant_union }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// A packet envelope sent/received over the mesh
/// only payload_variant is sent in the payload portion of the LORA packet.
/// The other fields are either not sent at all, or sent in the special 16 byte LORA header.
pub const MeshPacket = struct {
    from: u32 = 0,
    to: u32 = 0,
    channel: u32 = 0,
    id: u32 = 0,
    rx_time: u32 = 0,
    rx_snr: f32 = 0,
    hop_limit: u32 = 0,
    want_ack: bool = false,
    priority: MeshPacket.Priority = @enumFromInt(0),
    rx_rssi: i32 = 0,
    delayed: MeshPacket.Delayed = @enumFromInt(0),
    via_mqtt: bool = false,
    hop_start: u32 = 0,
    public_key: []const u8 = &.{},
    pki_encrypted: bool = false,
    next_hop: u32 = 0,
    relay_node: u32 = 0,
    tx_after: u32 = 0,
    transport_mechanism: MeshPacket.TransportMechanism = @enumFromInt(0),
    payload_variant: ?payload_variant_union = null,

    pub const _payload_variant_case = enum {
        decoded,
        encrypted,
    };
    pub const payload_variant_union = union(_payload_variant_case) {
        decoded: Data,
        encrypted: []const u8,
        pub const _desc_table = .{
            .decoded = fd(4, .submessage),
            .encrypted = fd(5, .{ .scalar = .bytes }),
        };
    };

    pub const _desc_table = .{
        .from = fd(1, .{ .scalar = .fixed32 }),
        .to = fd(2, .{ .scalar = .fixed32 }),
        .channel = fd(3, .{ .scalar = .uint32 }),
        .id = fd(6, .{ .scalar = .fixed32 }),
        .rx_time = fd(7, .{ .scalar = .fixed32 }),
        .rx_snr = fd(8, .{ .scalar = .float }),
        .hop_limit = fd(9, .{ .scalar = .uint32 }),
        .want_ack = fd(10, .{ .scalar = .bool }),
        .priority = fd(11, .@"enum"),
        .rx_rssi = fd(12, .{ .scalar = .int32 }),
        .delayed = fd(13, .@"enum"),
        .via_mqtt = fd(14, .{ .scalar = .bool }),
        .hop_start = fd(15, .{ .scalar = .uint32 }),
        .public_key = fd(16, .{ .scalar = .bytes }),
        .pki_encrypted = fd(17, .{ .scalar = .bool }),
        .next_hop = fd(18, .{ .scalar = .uint32 }),
        .relay_node = fd(19, .{ .scalar = .uint32 }),
        .tx_after = fd(20, .{ .scalar = .uint32 }),
        .transport_mechanism = fd(21, .@"enum"),
        .payload_variant = fd(null, .{ .oneof = payload_variant_union }),
    };

    ///
    /// The priority of this message for sending.
    /// Higher priorities are sent first (when managing the transmit queue).
    /// This field is never sent over the air, it is only used internally inside of a local device node.
    /// API clients (either on the local node or connected directly to the node)
    /// can set this parameter if necessary.
    /// (values must be <= 127 to keep protobuf field to one byte in size.
    /// Detailed background on this field:
    /// I noticed a funny side effect of lora being so slow: Usually when making
    /// a protocol there isnt much need to use message priority to change the order
    /// of transmission (because interfaces are fairly fast).
    /// But for lora where packets can take a few seconds each, it is very important
    /// to make sure that critical packets are sent ASAP.
    /// In the case of meshtastic that means we want to send protocol acks as soon as possible
    /// (to prevent unneeded retransmissions), we want routing messages to be sent next,
    /// then messages marked as reliable and finally 'background' packets like periodic position updates.
    /// So I bit the bullet and implemented a new (internal - not sent over the air)
    /// field in MeshPacket called 'priority'.
    /// And the transmission queue in the router object is now a priority queue.
    pub const Priority = enum(i32) {
        UNSET = 0,
        MIN = 1,
        BACKGROUND = 10,
        DEFAULT = 64,
        RELIABLE = 70,
        RESPONSE = 80,
        HIGH = 100,
        ALERT = 110,
        ACK = 120,
        MAX = 127,
        _,
    };

    ///
    /// Identify if this is a delayed packet
    pub const Delayed = enum(i32) {
        NO_DELAY = 0,
        DELAYED_BROADCAST = 1,
        DELAYED_DIRECT = 2,
        _,
    };

    ///
    /// Enum to identify which transport mechanism this packet arrived over
    pub const TransportMechanism = enum(i32) {
        TRANSPORT_INTERNAL = 0,
        TRANSPORT_LORA = 1,
        TRANSPORT_LORA_ALT1 = 2,
        TRANSPORT_LORA_ALT2 = 3,
        TRANSPORT_LORA_ALT3 = 4,
        TRANSPORT_MQTT = 5,
        TRANSPORT_MULTICAST_UDP = 6,
        TRANSPORT_API = 7,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// The bluetooth to device link:
/// Old BTLE protocol docs from TODO, merge in above and make real docs...
/// use protocol buffers, and NanoPB
/// messages from device to phone:
/// POSITION_UPDATE (..., time)
/// TEXT_RECEIVED(from, text, time)
/// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
/// messages from phone to device:
/// SET_MYID(id, human readable long, human readable short) (send down the unique ID
/// string used for this node, a human readable string shown for that id, and a very
/// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
/// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
/// nodes() (returns list of nodes, with full info, last time seen, loc, battery
/// level etc) SET_CONFIG (switches device to a new set of radio params and
/// preshared key, drops all existing nodes, force our node to rejoin this new group)
/// Full information about a node on the mesh
pub const NodeInfo = struct {
    num: u32 = 0,
    user: ?User = null,
    position: ?Position = null,
    snr: f32 = 0,
    last_heard: u32 = 0,
    device_metrics: ?DeviceMetrics = null,
    channel: u32 = 0,
    via_mqtt: bool = false,
    hops_away: ?u32 = null,
    is_favorite: bool = false,
    is_ignored: bool = false,
    is_key_manually_verified: bool = false,
    is_muted: bool = false,

    pub const _desc_table = .{
        .num = fd(1, .{ .scalar = .uint32 }),
        .user = fd(2, .submessage),
        .position = fd(3, .submessage),
        .snr = fd(4, .{ .scalar = .float }),
        .last_heard = fd(5, .{ .scalar = .fixed32 }),
        .device_metrics = fd(6, .submessage),
        .channel = fd(7, .{ .scalar = .uint32 }),
        .via_mqtt = fd(8, .{ .scalar = .bool }),
        .hops_away = fd(9, .{ .scalar = .uint32 }),
        .is_favorite = fd(10, .{ .scalar = .bool }),
        .is_ignored = fd(11, .{ .scalar = .bool }),
        .is_key_manually_verified = fd(12, .{ .scalar = .bool }),
        .is_muted = fd(13, .{ .scalar = .bool }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Unique local debugging info for this node
/// Note: we don't include position or the user info, because that will come in the
/// Sent to the phone in response to WantNodes.
pub const MyNodeInfo = struct {
    my_node_num: u32 = 0,
    reboot_count: u32 = 0,
    min_app_version: u32 = 0,
    device_id: []const u8 = &.{},
    pio_env: []const u8 = &.{},
    firmware_edition: FirmwareEdition = @enumFromInt(0),
    nodedb_count: u32 = 0,

    pub const _desc_table = .{
        .my_node_num = fd(1, .{ .scalar = .uint32 }),
        .reboot_count = fd(8, .{ .scalar = .uint32 }),
        .min_app_version = fd(11, .{ .scalar = .uint32 }),
        .device_id = fd(12, .{ .scalar = .bytes }),
        .pio_env = fd(13, .{ .scalar = .string }),
        .firmware_edition = fd(14, .@"enum"),
        .nodedb_count = fd(15, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Debug output from the device.
/// To minimize the size of records inside the device code, if a time/source/level is not set
/// on the message it is assumed to be a continuation of the previously sent message.
/// This allows the device code to use fixed maxlen 64 byte strings for messages,
/// and then extend as needed by emitting multiple records.
pub const LogRecord = struct {
    message: []const u8 = &.{},
    time: u32 = 0,
    source: []const u8 = &.{},
    level: LogRecord.Level = @enumFromInt(0),

    pub const _desc_table = .{
        .message = fd(1, .{ .scalar = .string }),
        .time = fd(2, .{ .scalar = .fixed32 }),
        .source = fd(3, .{ .scalar = .string }),
        .level = fd(4, .@"enum"),
    };

    ///
    /// Log levels, chosen to match python logging conventions.
    pub const Level = enum(i32) {
        UNSET = 0,
        CRITICAL = 50,
        ERROR = 40,
        WARNING = 30,
        INFO = 20,
        DEBUG = 10,
        TRACE = 5,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const QueueStatus = struct {
    res: i32 = 0,
    free: u32 = 0,
    maxlen: u32 = 0,
    mesh_packet_id: u32 = 0,

    pub const _desc_table = .{
        .res = fd(1, .{ .scalar = .int32 }),
        .free = fd(2, .{ .scalar = .uint32 }),
        .maxlen = fd(3, .{ .scalar = .uint32 }),
        .mesh_packet_id = fd(4, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Packets from the radio to the phone will appear on the fromRadio characteristic.
/// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
/// It will sit in that descriptor until consumed by the phone,
/// at which point the next item in the FIFO will be populated.
pub const FromRadio = struct {
    id: u32 = 0,
    payload_variant: ?payload_variant_union = null,

    pub const _payload_variant_case = enum {
        packet,
        my_info,
        node_info,
        config,
        log_record,
        config_complete_id,
        rebooted,
        moduleConfig,
        channel,
        queueStatus,
        xmodemPacket,
        metadata,
        mqttClientProxyMessage,
        fileInfo,
        clientNotification,
        deviceuiConfig,
    };
    pub const payload_variant_union = union(_payload_variant_case) {
        packet: MeshPacket,
        my_info: MyNodeInfo,
        node_info: NodeInfo,
        config: Config,
        log_record: LogRecord,
        config_complete_id: u32,
        rebooted: bool,
        moduleConfig: ModuleConfig,
        channel: Channel,
        queueStatus: QueueStatus,
        xmodemPacket: XModem,
        metadata: DeviceMetadata,
        mqttClientProxyMessage: MqttClientProxyMessage,
        fileInfo: FileInfo,
        clientNotification: ClientNotification,
        deviceuiConfig: DeviceUIConfig,
        pub const _desc_table = .{
            .packet = fd(2, .submessage),
            .my_info = fd(3, .submessage),
            .node_info = fd(4, .submessage),
            .config = fd(5, .submessage),
            .log_record = fd(6, .submessage),
            .config_complete_id = fd(7, .{ .scalar = .uint32 }),
            .rebooted = fd(8, .{ .scalar = .bool }),
            .moduleConfig = fd(9, .submessage),
            .channel = fd(10, .submessage),
            .queueStatus = fd(11, .submessage),
            .xmodemPacket = fd(12, .submessage),
            .metadata = fd(13, .submessage),
            .mqttClientProxyMessage = fd(14, .submessage),
            .fileInfo = fd(15, .submessage),
            .clientNotification = fd(16, .submessage),
            .deviceuiConfig = fd(17, .submessage),
        };
    };

    pub const _desc_table = .{
        .id = fd(1, .{ .scalar = .uint32 }),
        .payload_variant = fd(null, .{ .oneof = payload_variant_union }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// A notification message from the device to the client
/// To be used for important messages that should to be displayed to the user
/// in the form of push notifications or validation messages when saving
/// invalid configuration.
pub const ClientNotification = struct {
    reply_id: ?u32 = null,
    time: u32 = 0,
    level: LogRecord.Level = @enumFromInt(0),
    message: []const u8 = &.{},
    payload_variant: ?payload_variant_union = null,

    pub const _payload_variant_case = enum {
        key_verification_number_inform,
        key_verification_number_request,
        key_verification_final,
        duplicated_public_key,
        low_entropy_key,
    };
    pub const payload_variant_union = union(_payload_variant_case) {
        key_verification_number_inform: KeyVerificationNumberInform,
        key_verification_number_request: KeyVerificationNumberRequest,
        key_verification_final: KeyVerificationFinal,
        duplicated_public_key: DuplicatedPublicKey,
        low_entropy_key: LowEntropyKey,
        pub const _desc_table = .{
            .key_verification_number_inform = fd(11, .submessage),
            .key_verification_number_request = fd(12, .submessage),
            .key_verification_final = fd(13, .submessage),
            .duplicated_public_key = fd(14, .submessage),
            .low_entropy_key = fd(15, .submessage),
        };
    };

    pub const _desc_table = .{
        .reply_id = fd(1, .{ .scalar = .uint32 }),
        .time = fd(2, .{ .scalar = .fixed32 }),
        .level = fd(3, .@"enum"),
        .message = fd(4, .{ .scalar = .string }),
        .payload_variant = fd(null, .{ .oneof = payload_variant_union }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const KeyVerificationNumberInform = struct {
    nonce: u64 = 0,
    remote_longname: []const u8 = &.{},
    security_number: u32 = 0,

    pub const _desc_table = .{
        .nonce = fd(1, .{ .scalar = .uint64 }),
        .remote_longname = fd(2, .{ .scalar = .string }),
        .security_number = fd(3, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const KeyVerificationNumberRequest = struct {
    nonce: u64 = 0,
    remote_longname: []const u8 = &.{},

    pub const _desc_table = .{
        .nonce = fd(1, .{ .scalar = .uint64 }),
        .remote_longname = fd(2, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const KeyVerificationFinal = struct {
    nonce: u64 = 0,
    remote_longname: []const u8 = &.{},
    isSender: bool = false,
    verification_characters: []const u8 = &.{},

    pub const _desc_table = .{
        .nonce = fd(1, .{ .scalar = .uint64 }),
        .remote_longname = fd(2, .{ .scalar = .string }),
        .isSender = fd(3, .{ .scalar = .bool }),
        .verification_characters = fd(4, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const DuplicatedPublicKey = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const LowEntropyKey = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Individual File info for the device
pub const FileInfo = struct {
    file_name: []const u8 = &.{},
    size_bytes: u32 = 0,

    pub const _desc_table = .{
        .file_name = fd(1, .{ .scalar = .string }),
        .size_bytes = fd(2, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Packets/commands to the radio will be written (reliably) to the toRadio characteristic.
/// Once the write completes the phone can assume it is handled.
pub const ToRadio = struct {
    payload_variant: ?payload_variant_union = null,

    pub const _payload_variant_case = enum {
        packet,
        want_config_id,
        disconnect,
        xmodemPacket,
        mqttClientProxyMessage,
        heartbeat,
    };
    pub const payload_variant_union = union(_payload_variant_case) {
        packet: MeshPacket,
        want_config_id: u32,
        disconnect: bool,
        xmodemPacket: XModem,
        mqttClientProxyMessage: MqttClientProxyMessage,
        heartbeat: Heartbeat,
        pub const _desc_table = .{
            .packet = fd(1, .submessage),
            .want_config_id = fd(3, .{ .scalar = .uint32 }),
            .disconnect = fd(4, .{ .scalar = .bool }),
            .xmodemPacket = fd(5, .submessage),
            .mqttClientProxyMessage = fd(6, .submessage),
            .heartbeat = fd(7, .submessage),
        };
    };

    pub const _desc_table = .{
        .payload_variant = fd(null, .{ .oneof = payload_variant_union }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Compressed message payload
pub const Compressed = struct {
    portnum: PortNum = @enumFromInt(0),
    data: []const u8 = &.{},

    pub const _desc_table = .{
        .portnum = fd(1, .@"enum"),
        .data = fd(2, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Full info on edges for a single node
pub const NeighborInfo = struct {
    node_id: u32 = 0,
    last_sent_by_id: u32 = 0,
    node_broadcast_interval_secs: u32 = 0,
    neighbors: std.ArrayListUnmanaged(Neighbor) = .empty,

    pub const _desc_table = .{
        .node_id = fd(1, .{ .scalar = .uint32 }),
        .last_sent_by_id = fd(2, .{ .scalar = .uint32 }),
        .node_broadcast_interval_secs = fd(3, .{ .scalar = .uint32 }),
        .neighbors = fd(4, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// A single edge in the mesh
pub const Neighbor = struct {
    node_id: u32 = 0,
    snr: f32 = 0,
    last_rx_time: u32 = 0,
    node_broadcast_interval_secs: u32 = 0,

    pub const _desc_table = .{
        .node_id = fd(1, .{ .scalar = .uint32 }),
        .snr = fd(2, .{ .scalar = .float }),
        .last_rx_time = fd(3, .{ .scalar = .fixed32 }),
        .node_broadcast_interval_secs = fd(4, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Device metadata response
pub const DeviceMetadata = struct {
    firmware_version: []const u8 = &.{},
    device_state_version: u32 = 0,
    canShutdown: bool = false,
    hasWifi: bool = false,
    hasBluetooth: bool = false,
    hasEthernet: bool = false,
    role: Config.DeviceConfig.Role = @enumFromInt(0),
    position_flags: u32 = 0,
    hw_model: HardwareModel = @enumFromInt(0),
    hasRemoteHardware: bool = false,
    hasPKC: bool = false,
    excluded_modules: u32 = 0,

    pub const _desc_table = .{
        .firmware_version = fd(1, .{ .scalar = .string }),
        .device_state_version = fd(2, .{ .scalar = .uint32 }),
        .canShutdown = fd(3, .{ .scalar = .bool }),
        .hasWifi = fd(4, .{ .scalar = .bool }),
        .hasBluetooth = fd(5, .{ .scalar = .bool }),
        .hasEthernet = fd(6, .{ .scalar = .bool }),
        .role = fd(7, .@"enum"),
        .position_flags = fd(8, .{ .scalar = .uint32 }),
        .hw_model = fd(9, .@"enum"),
        .hasRemoteHardware = fd(10, .{ .scalar = .bool }),
        .hasPKC = fd(11, .{ .scalar = .bool }),
        .excluded_modules = fd(12, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// A heartbeat message is sent to the node from the client to keep the connection alive.
/// This is currently only needed to keep serial connections alive, but can be used by any PhoneAPI.
pub const Heartbeat = struct {
    nonce: u32 = 0,

    pub const _desc_table = .{
        .nonce = fd(1, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// RemoteHardwarePins associated with a node
pub const NodeRemoteHardwarePin = struct {
    node_num: u32 = 0,
    pin: ?RemoteHardwarePin = null,

    pub const _desc_table = .{
        .node_num = fd(1, .{ .scalar = .uint32 }),
        .pin = fd(2, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const ChunkedPayload = struct {
    payload_id: u32 = 0,
    chunk_count: u32 = 0,
    chunk_index: u32 = 0,
    payload_chunk: []const u8 = &.{},

    pub const _desc_table = .{
        .payload_id = fd(1, .{ .scalar = .uint32 }),
        .chunk_count = fd(2, .{ .scalar = .uint32 }),
        .chunk_index = fd(3, .{ .scalar = .uint32 }),
        .payload_chunk = fd(4, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Wrapper message for broken repeated oneof support
pub const resend_chunks = struct {
    chunks: std.ArrayListUnmanaged(u32) = .empty,

    pub const _desc_table = .{
        .chunks = fd(1, .{ .packed_repeated = .{ .scalar = .uint32 } }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

///
/// Responses to a ChunkedPayload request
pub const ChunkedPayloadResponse = struct {
    payload_id: u32 = 0,
    payload_variant: ?payload_variant_union = null,

    pub const _payload_variant_case = enum {
        request_transfer,
        accept_transfer,
        resend_chunks,
    };
    pub const payload_variant_union = union(_payload_variant_case) {
        request_transfer: bool,
        accept_transfer: bool,
        resend_chunks: resend_chunks,
        pub const _desc_table = .{
            .request_transfer = fd(2, .{ .scalar = .bool }),
            .accept_transfer = fd(3, .{ .scalar = .bool }),
            .resend_chunks = fd(4, .submessage),
        };
    };

    pub const _desc_table = .{
        .payload_id = fd(1, .{ .scalar = .uint32 }),
        .payload_variant = fd(null, .{ .oneof = payload_variant_union }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};
